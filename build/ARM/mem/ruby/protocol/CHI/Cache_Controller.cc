/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   src/mem/slicc/symbols/StateMachine.py:1472
 */

// Created by slicc definition of Module "Cache coherency protocol"

#include <sys/types.h>
#include <unistd.h>

#include <cassert>
#include <sstream>
#include <string>
#include <typeinfo>

#include "mem/ruby/common/BoolVec.hh"

#include "base/compiler.hh"
#include "base/cprintf.hh"

#include "debug/LLSC.hh"
#include "debug/RubyGenerated.hh"
#include "debug/RubyProtocol.hh"
#include "debug/RubySlicc.hh"
#include "mem/ruby/network/Network.hh"
#include "mem/ruby/protocol/CHI/Cache_Controller.hh"
#include "mem/ruby/protocol/CHI/Cache_Event.hh"
#include "mem/ruby/protocol/CHI/Cache_State.hh"
#include "mem/ruby/protocol/CHI/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#include "mem/ruby/slicc_interface/RubySlicc_includes.hh"
#include "mem/ruby/protocol/PerfectCacheMemory.hh"
#include "mem/ruby/protocol/TimerTable.hh"
#include "mem/ruby/protocol/TBETable.hh"
#include "mem/ruby/protocol/TBEStorage.hh"
#include "mem/ruby/protocol/RubyPrefetcherProxy.hh"
#include "mem/ruby/protocol/TriggerQueue.hh"
#include "mem/ruby/protocol/NetDest.hh"
namespace gem5
{

namespace ruby
{

namespace CHI
{

// for adding information to the protocol debug trace
std::stringstream Cache_transitionComment;

#ifndef NDEBUG
#define APPEND_TRANSITION_COMMENT(str) (Cache_transitionComment << str)
#else
#define APPEND_TRANSITION_COMMENT(str) do {} while (0)
#endif

/** \brief constructor */
Cache_Controller::Cache_Controller(const Params &p)
    : AbstractController(p)
{
    m_machineID.type = MachineType_Cache;
    m_machineID.num = m_version;
    p.ruby_system->m_num_controllers[MachineType_Cache]++;
    p.ruby_system->registerAbstractController(this, std::make_unique<CHIProtocolInfo>());
    m_ruby_system = p.ruby_system;

    m_in_ports = 12;
    m_sequencer_ptr = p.sequencer;
    if (m_sequencer_ptr != NULL) {
        m_sequencer_ptr->setController(this);
    }
    m_cache_ptr = p.cache;
    m_prefetcher_ptr = p.prefetcher;
    m_read_hit_latency = p.read_hit_latency;
    m_read_miss_latency = p.read_miss_latency;
    m_atomic_op_latency = p.atomic_op_latency;
    m_write_fe_latency = p.write_fe_latency;
    m_write_be_latency = p.write_be_latency;
    m_fill_latency = p.fill_latency;
    m_snp_latency = p.snp_latency;
    m_snp_inv_latency = p.snp_inv_latency;
    m_wait_for_cache_wr = p.wait_for_cache_wr;
    m_allocation_latency = p.allocation_latency;
    m_request_latency = p.request_latency;
    m_response_latency = p.response_latency;
    m_snoop_latency = p.snoop_latency;
    m_data_latency = p.data_latency;
    m_dvm_ext_tlbi_latency = p.dvm_ext_tlbi_latency;
    m_sc_lock_base_latency_cy = p.sc_lock_base_latency_cy;
    m_sc_lock_multiplier_inc = p.sc_lock_multiplier_inc;
    m_sc_lock_multiplier_decay = p.sc_lock_multiplier_decay;
    m_sc_lock_multiplier_max = p.sc_lock_multiplier_max;
    m_sc_lock_enabled = p.sc_lock_enabled;
    m_max_outstanding_transactions = p.max_outstanding_transactions;
    m_stall_recycle_lat = p.stall_recycle_lat;
    m_send_evictions = p.send_evictions;
    m_number_of_snoop_TBEs = p.number_of_snoop_TBEs;
    m_number_of_repl_TBEs = p.number_of_repl_TBEs;
    m_number_of_DVM_TBEs = p.number_of_DVM_TBEs;
    m_number_of_DVM_snoop_TBEs = p.number_of_DVM_snoop_TBEs;
    m_unify_repl_TBEs = p.unify_repl_TBEs;
    m_dealloc_wait_for_tag = p.dealloc_wait_for_tag;
    m_data_channel_size = p.data_channel_size;
    m_is_HN = p.is_HN;
    m_enable_DMT = p.enable_DMT;
    m_enable_DMT_early_dealloc = p.enable_DMT_early_dealloc;
    m_enable_DCT = p.enable_DCT;
    m_policy_type = p.policy_type;
    m_comp_wu = p.comp_wu;
    m_comp_wu_latency = p.comp_wu_latency;
    m_comp_anr = p.comp_anr;
    m_comp_anr_latency = p.comp_anr_latency;
    m_alloc_on_readshared = p.alloc_on_readshared;
    m_alloc_on_readunique = p.alloc_on_readunique;
    m_alloc_on_readonce = p.alloc_on_readonce;
    m_alloc_on_writeback = p.alloc_on_writeback;
    m_alloc_on_seq_acc = p.alloc_on_seq_acc;
    m_alloc_on_seq_line_write = p.alloc_on_seq_line_write;
    m_alloc_on_atomic = p.alloc_on_atomic;
    m_dealloc_on_unique = p.dealloc_on_unique;
    m_dealloc_on_shared = p.dealloc_on_shared;
    m_dealloc_backinv_unique = p.dealloc_backinv_unique;
    m_dealloc_backinv_shared = p.dealloc_backinv_shared;
    m_fwd_unique_on_readshared = p.fwd_unique_on_readshared;
    m_allow_SD = p.allow_SD;
    m_throttle_req_on_retry = p.throttle_req_on_retry;
    m_use_prefetcher = p.use_prefetcher;
    m_reqOut_ptr = p.reqOut;
    m_snpOut_ptr = p.snpOut;
    m_rspOut_ptr = p.rspOut;
    m_datOut_ptr = p.datOut;
    m_reqIn_ptr = p.reqIn;
    m_snpIn_ptr = p.snpIn;
    m_rspIn_ptr = p.rspIn;
    m_datIn_ptr = p.datIn;
    m_mandatoryQueue_ptr = p.mandatoryQueue;
    m_triggerQueue_ptr = p.triggerQueue;
    m_retryTriggerQueue_ptr = p.retryTriggerQueue;
    m_reqRdy_ptr = p.reqRdy;
    m_snpRdy_ptr = p.snpRdy;
    m_replTriggerQueue_ptr = p.replTriggerQueue;
    m_prefetchQueue_ptr = p.prefetchQueue;
    m_upstream_prefetch_trains_prefetcher = p.upstream_prefetch_trains_prefetcher;

    for (int state = 0; state < Cache_State_NUM; state++) {
        for (int event = 0; event < Cache_Event_NUM; event++) {
            m_possible[state][event] = false;
            m_counters[state][event] = 0;
        }
    }
    for (int event = 0; event < Cache_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }
}

void
Cache_Controller::initNetQueues()
{
    MachineType machine_type = string_to_MachineType("Cache");
    [[maybe_unused]] int base = m_ruby_system->MachineType_base_number(machine_type);

    assert(m_reqOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_reqOut_ptr->getOrdered(), 0,
                                     "none", m_reqOut_ptr);
    assert(m_snpOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_snpOut_ptr->getOrdered(), 1,
                                     "none", m_snpOut_ptr);
    assert(m_rspOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_rspOut_ptr->getOrdered(), 2,
                                     "none", m_rspOut_ptr);
    assert(m_datOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_datOut_ptr->getOrdered(), 3,
                                     "response", m_datOut_ptr);
    assert(m_reqIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_reqIn_ptr->getOrdered(), 0,
                                     "none", m_reqIn_ptr);
    assert(m_snpIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_snpIn_ptr->getOrdered(), 1,
                                     "none", m_snpIn_ptr);
    assert(m_rspIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_rspIn_ptr->getOrdered(), 2,
                                     "none", m_rspIn_ptr);
    assert(m_datIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_datIn_ptr->getOrdered(), 3,
                                     "response", m_datIn_ptr);
}

void
Cache_Controller::init()
{
    // initialize objects
    m_blockSize_ptr = new int;
    (*m_blockSize_ptr) = m_ruby_system->getBlockSizeBytes();
    m_directory_ptr  = new PerfectCacheMemory<Cache_DirEntry>();
    assert(m_directory_ptr != NULL);
    (*m_directory_ptr).setRubySystem(m_ruby_system);
    m_useTimerTable_ptr  = new TimerTable();
    assert(m_useTimerTable_ptr != NULL);
    m_sc_lock_multiplier_ptr = new int;
    (*m_sc_lock_multiplier_ptr) = 0;
    m_TBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_TBEs);
    assert(m_TBEs_ptr != NULL);
    (*m_TBEs_ptr).setRubySystem(m_ruby_system);
    m_storTBEs_ptr  = new TBEStorage(this, m_number_of_TBEs);
    assert(m_storTBEs_ptr != NULL);
    m_replTBEs_ptr  = new TBETable<Cache_TBE>(m_unify_repl_TBEs ? m_number_of_TBEs : m_number_of_repl_TBEs);
    assert(m_replTBEs_ptr != NULL);
    (*m_replTBEs_ptr).setRubySystem(m_ruby_system);
    m_storReplTBEs_ptr  = new TBEStorage(this, m_number_of_repl_TBEs);
    assert(m_storReplTBEs_ptr != NULL);
    m_snpTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_snoop_TBEs);
    assert(m_snpTBEs_ptr != NULL);
    (*m_snpTBEs_ptr).setRubySystem(m_ruby_system);
    m_storSnpTBEs_ptr  = new TBEStorage(this, m_number_of_snoop_TBEs);
    assert(m_storSnpTBEs_ptr != NULL);
    m_dvmTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_DVM_TBEs);
    assert(m_dvmTBEs_ptr != NULL);
    (*m_dvmTBEs_ptr).setRubySystem(m_ruby_system);
    m_storDvmTBEs_ptr  = new TBEStorage(this, m_number_of_DVM_TBEs);
    assert(m_storDvmTBEs_ptr != NULL);
    m_dvmSnpTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_DVM_snoop_TBEs);
    assert(m_dvmSnpTBEs_ptr != NULL);
    (*m_dvmSnpTBEs_ptr).setRubySystem(m_ruby_system);
    m_storDvmSnpTBEs_ptr  = new TBEStorage(this, m_number_of_DVM_snoop_TBEs);
    assert(m_storDvmSnpTBEs_ptr != NULL);
    m_pfProxy_ptr  = new RubyPrefetcherProxy(this, m_prefetcher_ptr, m_prefetchQueue_ptr);
    assert(m_pfProxy_ptr != NULL);
    m_dvmPendingNonSyncsBlockingSync_ptr  = new TriggerQueue<Cache_Event>();
    assert(m_dvmPendingNonSyncsBlockingSync_ptr != NULL);
    m_dvmHasPendingSyncOp_ptr = new bool;
    (*m_dvmHasPendingSyncOp_ptr) = false;
    m_dvmPendingSyncOp_ptr = new Addr;
    (*m_dvmPendingSyncOp_ptr) = 0;
    m_retryQueue_ptr  = new TriggerQueue<Cache_RetryQueueEntry>();
    assert(m_retryQueue_ptr != NULL);
    m_destsWaitingRetry_ptr  = new NetDest();
    assert(m_destsWaitingRetry_ptr != NULL);
    (*m_destsWaitingRetry_ptr).setRubySystem(m_ruby_system);
    m_cache_ptr->setRubySystem(m_ruby_system);


    (*m_useTimerTable_ptr).setConsumer(this);
    (*m_rspIn_ptr).setConsumer(this);
    (*m_datIn_ptr).setConsumer(this);
    (*m_snpRdy_ptr).setConsumer(this);
    (*m_snpIn_ptr).setConsumer(this);
    (*m_retryTriggerQueue_ptr).setConsumer(this);
    (*m_triggerQueue_ptr).setConsumer(this);
    (*m_replTriggerQueue_ptr).setConsumer(this);
    (*m_reqRdy_ptr).setConsumer(this);
    (*m_reqIn_ptr).setConsumer(this);
    (*m_mandatoryQueue_ptr).setConsumer(this);
    (*m_prefetchQueue_ptr).setConsumer(this);

    possibleTransition(Cache_State_I, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_I, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RUSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RUSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_I, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RUSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RUSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_I, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_I, Cache_Event_AllocDvmSnoop);
    possibleTransition(Cache_State_UD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocSeqDvmRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_TagArrayRead);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TagArrayRead);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_TagArrayWrite);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TagArrayWrite);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayRead);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayRead);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CheckCacheFill);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckCacheFill);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayWrite);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayWrite);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayWriteOnFill);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayWriteOnFill);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadHitPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadHitPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadMissPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadMissPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteFEPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteFEPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBEPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBEPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_FillPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FillPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DelayAtomic);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DelayAtomic);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpSharedPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpSharedPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpInvPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpInvPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOncePipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOncePipe);
    possibleTransition(Cache_State_I, Cache_Event_ReadShared);
    possibleTransition(Cache_State_I, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_I, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_UD, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_SD, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_UC, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_SC, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_I, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_I, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_I, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FinishMakeReadUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_FinishMakeReadUnique);
    possibleTransition(Cache_State_I, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_I, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_I, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_I, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_RSD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_RUSD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_RUSC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_RSC, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_RU, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_I, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_RSD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_RUSD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_RUSC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_RSC, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_RU, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_RSD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_RUSC, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_RUSD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_RU, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_RSC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_RSD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_RUSC, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_RUSD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_RU, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_RSC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_I, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_I, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_I, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_I, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_Load);
    possibleTransition(Cache_State_UD_T, Cache_Event_Load);
    possibleTransition(Cache_State_SD, Cache_Event_Load);
    possibleTransition(Cache_State_UC, Cache_Event_Load);
    possibleTransition(Cache_State_SC, Cache_Event_Load);
    possibleTransition(Cache_State_UD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_T, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RUSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RUSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_LoadHit);
    possibleTransition(Cache_State_UD, Cache_Event_Store);
    possibleTransition(Cache_State_UD_T, Cache_Event_Store);
    possibleTransition(Cache_State_UC, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_StoreHit);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_UC, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_UD, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_UD_T, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_UD_T, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicHit);
    possibleTransition(Cache_State_I, Cache_Event_Load);
    possibleTransition(Cache_State_I, Cache_Event_Prefetch);
    possibleTransition(Cache_State_I, Cache_Event_Store);
    possibleTransition(Cache_State_SD, Cache_Event_Store);
    possibleTransition(Cache_State_SC, Cache_Event_Store);
    possibleTransition(Cache_State_UD_T, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_I, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_I, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_SD, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_SC, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_RUSD, Cache_Event_Evict);
    possibleTransition(Cache_State_RUSC, Cache_Event_Evict);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_UD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_I, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RUSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RUSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RUSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RUSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_I, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_I, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_SC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_SC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_SD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_SD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_RU, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_RU, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_RSC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_RSD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Load);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Evict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadNoSnp);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Load);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicLoad);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicStore);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_MakeReadUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Evict);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueZero);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicReturn);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicReturn_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicReturn_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicNoReturn);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicNoReturn_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AtomicNoReturn_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_StashOnceShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_StashOnceUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpStalled);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpStalled);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ActionStalledOnHazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ActionStalledOnHazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteBackOrWriteEvict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteClean);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendAtomicReturn);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendAtomicNoReturn);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteNoSnpPartial);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendEvict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWBData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWUData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWUDataCB);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendARData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendARData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendANRData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendANRData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendInvSnpResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpNotSharedDirtyFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnceFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpFwdedData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpFwdedResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpIResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompIResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompUCResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompUCRespStale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompUDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendRespSepData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WaitCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WaitCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RestoreFromHazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendMakeReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadNoSnpDMT);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdToOwner);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdToSharer);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueRetToSrc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpCleanInvalidNoReq);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendDBIDResp_WUZ);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendDBIDResp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendComp_WU);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendComp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp_ANR);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendDBIDResp_AR);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompData_AR);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendCompData_AR);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDRespStale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_MaintainCoherence);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FinishCleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FinishCopyBack_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromStore);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromCU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromRU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_UD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_NCBWrData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_NCBWrData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_UD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_PD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_PD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RespSepData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RespSepData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataSepResp_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataSepResp_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_UD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_SC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_SD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_UD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadReceipt);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DoRetry);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DoRetry);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DoRetry_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DoRetry_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I_Fwded_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I_Fwded_UD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_UC_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_UD_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SD_Fwded_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Comp_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Comp_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompDBIDResp);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Comp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TX_Data);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteZero);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Final);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Final);
    possibleTransition(Cache_State_I, Cache_Event_DvmTlbi_Initiate);
    possibleTransition(Cache_State_I, Cache_Event_DvmSync_Initiate);
    possibleTransition(Cache_State_DvmSync_Unsent, Cache_Event_DvmSync_Send);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_RetryAck);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_RetryAck);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_DoRetry);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_DoRetry);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_CompDBIDResp);
    possibleTransition(Cache_State_DvmTlbi_Waiting, Cache_Event_Comp);
    possibleTransition(Cache_State_DvmSync_Waiting, Cache_Event_Comp);
    possibleTransition(Cache_State_DvmOp_Finished, Cache_Event_Final);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpNonSync_P1);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpNonSync_P2);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpSync_P1);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpSync_P2);
    possibleTransition(Cache_State_DvmExtTlbi_Partial, Cache_Event_SnpDvmOpNonSync_P1);
    possibleTransition(Cache_State_DvmExtTlbi_Partial, Cache_Event_SnpDvmOpNonSync_P2);
    possibleTransition(Cache_State_DvmExtSync_Partial, Cache_Event_SnpDvmOpSync_P1);
    possibleTransition(Cache_State_DvmExtSync_Partial, Cache_Event_SnpDvmOpSync_P2);
    possibleTransition(Cache_State_DvmExtTlbi_Executing, Cache_Event_SendSnpIResp);
    possibleTransition(Cache_State_DvmExtSync_Executing, Cache_Event_DvmSync_ExternCompleted);
    possibleTransition(Cache_State_DvmExtOp_Finished, Cache_Event_Final);
    AbstractController::init();
    resetStats();
}
Sequencer*
Cache_Controller::getCPUSequencer() const
{
    if (NULL != m_sequencer_ptr && m_sequencer_ptr->isCPUSequencer()) {
        return m_sequencer_ptr;
    } else {
        return NULL;
    }
}

DMASequencer*
Cache_Controller::getDMASequencer() const
{
    return NULL;
}

GPUCoalescer*
Cache_Controller::getGPUCoalescer() const
{
    return NULL;
}

void
Cache_Controller::regStats()
{
    AbstractController::regStats();

    // For each type of controllers, one controller of that type is picked
    // to aggregate stats of all controllers of that type.
    if (m_version == 0) {

        Profiler *profiler = params().ruby_system->getProfiler();
        statistics::Group *profilerStatsPtr = &profiler->rubyProfilerStats;

        for (Cache_Event event = Cache_Event_FIRST;
             event < Cache_Event_NUM; ++event) {
            std::string stat_name =
                "Cache_Controller." + Cache_Event_to_string(event);
            statistics::Vector *t =
                new statistics::Vector(profilerStatsPtr, stat_name.c_str());
            int num_controllers =
                m_ruby_system->m_num_controllers[MachineType_Cache];
            t->init(num_controllers);
            t->flags(statistics::pdf | statistics::total |
                statistics::oneline | statistics::nozero);

            eventVec.push_back(t);
        }

        for (Cache_State state = Cache_State_FIRST;
             state < Cache_State_NUM; ++state) {

            transVec.push_back(std::vector<statistics::Vector *>());

            for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
                std::string stat_name = "Cache_Controller." +
                    Cache_State_to_string(state) +
                    "." + Cache_Event_to_string(event);
                statistics::Vector *t = new statistics::Vector(
                    profilerStatsPtr, stat_name.c_str());
                int num_controllers =
                    m_ruby_system->m_num_controllers[MachineType_Cache];
                t->init(num_controllers);
                t->flags(statistics::pdf | statistics::total |
                    statistics::oneline | statistics::nozero);
                transVec[state].push_back(t);
            }
        }
    }

    const std::vector<Cache_Event> out_trans_evs = {Cache_Event_DvmTlbi_Initiate,Cache_Event_DvmSync_Initiate,Cache_Event_SendReadShared,Cache_Event_SendReadOnce,Cache_Event_SendReadNoSnp,Cache_Event_SendReadNoSnpDMT,Cache_Event_SendReadUnique,Cache_Event_SendMakeReadUnique,Cache_Event_SendWriteBackOrWriteEvict,Cache_Event_SendWriteClean,Cache_Event_SendWriteNoSnp,Cache_Event_SendWriteNoSnpPartial,Cache_Event_SendWriteUnique,Cache_Event_SendAtomicReturn,Cache_Event_SendAtomicNoReturn,Cache_Event_SendEvict,Cache_Event_SendCleanUnique};
    const std::vector<Cache_Event> in_trans_evs = {Cache_Event_Load,Cache_Event_Store,Cache_Event_AtomicLoad,Cache_Event_AtomicStore,Cache_Event_Prefetch,Cache_Event_ReadShared,Cache_Event_ReadNotSharedDirty,Cache_Event_ReadUnique,Cache_Event_ReadUnique_PoC,Cache_Event_ReadNoSnp,Cache_Event_ReadOnce,Cache_Event_CleanUnique,Cache_Event_MakeReadUnique,Cache_Event_Evict,Cache_Event_WriteBackFull,Cache_Event_WriteEvictFull,Cache_Event_WriteCleanFull,Cache_Event_WriteUnique,Cache_Event_WriteUniquePtl_PoC,Cache_Event_WriteUniqueFull_PoC,Cache_Event_WriteUniqueFull_PoC_Alloc,Cache_Event_WriteUniqueZero,Cache_Event_AtomicReturn,Cache_Event_AtomicNoReturn,Cache_Event_AtomicReturn_PoC,Cache_Event_AtomicReturn_PoC_Alloc,Cache_Event_AtomicNoReturn_PoC,Cache_Event_AtomicNoReturn_PoC_Alloc,Cache_Event_SnpCleanInvalid,Cache_Event_SnpShared,Cache_Event_SnpSharedFwd,Cache_Event_SnpNotSharedDirtyFwd,Cache_Event_SnpUnique,Cache_Event_SnpUniqueFwd,Cache_Event_SnpOnce,Cache_Event_SnpOnceFwd,Cache_Event_SnpStalled,Cache_Event_StashOnceShared,Cache_Event_StashOnceUnique,Cache_Event_DvmTlbi_Initiate,Cache_Event_DvmSync_Initiate,Cache_Event_SnpDvmOpSync_P1,Cache_Event_SnpDvmOpSync_P2,Cache_Event_SnpDvmOpNonSync_P1,Cache_Event_SnpDvmOpNonSync_P2,Cache_Event_Evict_Stale,Cache_Event_WriteBackFull_Stale,Cache_Event_WriteEvictFull_Stale,Cache_Event_WriteCleanFull_Stale,Cache_Event_CleanUnique_Stale,Cache_Event_Local_Eviction,Cache_Event_LocalHN_Eviction,Cache_Event_Global_Eviction};
    const std::unordered_map<Cache_Event, std::vector<Cache_State>>
                                in_trans_evs_states = {{Cache_Event_Load, {Cache_State_UD,Cache_State_UD_T,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_Store, {Cache_State_UD,Cache_State_UD_T,Cache_State_UC,Cache_State_I,Cache_State_SD,Cache_State_SC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicLoad, {Cache_State_UC,Cache_State_UD,Cache_State_UD_T,Cache_State_I,Cache_State_SD,Cache_State_SC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicStore, {Cache_State_UC,Cache_State_UD,Cache_State_UD_T,Cache_State_I,Cache_State_SD,Cache_State_SC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_Prefetch, {Cache_State_UD,Cache_State_UD_T,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_SD_RSD,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_ReadShared, {Cache_State_I,Cache_State_RSC,Cache_State_RUSC,Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RSD,Cache_State_RUSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_ReadNotSharedDirty, {Cache_State_I,Cache_State_RSC,Cache_State_RUSC,Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RSD,Cache_State_RUSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_ReadUnique, {Cache_State_I,Cache_State_UD,Cache_State_UC,Cache_State_UD_RSC,Cache_State_UC_RSC,Cache_State_UD_RSD,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC,Cache_State_SD,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_RSC,Cache_State_SD_RSD,Cache_State_RSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_ReadUnique_PoC, {Cache_State_I,Cache_State_UD,Cache_State_UC,Cache_State_UD_RSC,Cache_State_UC_RSC,Cache_State_UD_RSD,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC,Cache_State_SD,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_SD_RSD,Cache_State_RSC,Cache_State_RSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_ReadNoSnp, {Cache_State_I,Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_ReadOnce, {Cache_State_I,Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RSD,Cache_State_RUSD,Cache_State_RSC,Cache_State_RUSC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_CleanUnique, {Cache_State_I,Cache_State_SC,Cache_State_UC,Cache_State_SD,Cache_State_UD,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC_RSC,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_MakeReadUnique, {Cache_State_UD_RSC,Cache_State_UC_RSC,Cache_State_UD_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RSC,Cache_State_RSD,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_SD_RSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_Evict, {Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteBackFull, {Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSD,Cache_State_RUSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteEvictFull, {Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteCleanFull, {Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSD,Cache_State_RUSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteUnique, {Cache_State_UD,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RU,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteUniquePtl_PoC, {Cache_State_UD,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RU,Cache_State_RSC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteUniqueFull_PoC, {Cache_State_UD,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RU,Cache_State_RSC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteUniqueFull_PoC_Alloc, {Cache_State_UD,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RU,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteUniqueZero, {Cache_State_I,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC,Cache_State_UC,Cache_State_SD,Cache_State_UD,Cache_State_SC_RSC,Cache_State_UC_RSC,Cache_State_SD_RSC,Cache_State_UD_RSC,Cache_State_UC_RU,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicReturn, {Cache_State_I,Cache_State_SC,Cache_State_SC_RSC,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_UD,Cache_State_UD_RSC,Cache_State_UD_RSD,Cache_State_UD_RU,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_RSC,Cache_State_RU,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicNoReturn, {Cache_State_I,Cache_State_SC,Cache_State_SC_RSC,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_UD,Cache_State_UD_RSC,Cache_State_UD_RSD,Cache_State_UD_RU,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_RSC,Cache_State_RU,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicReturn_PoC, {Cache_State_UD,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RU,Cache_State_UC_RSC,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_RU,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicReturn_PoC_Alloc, {Cache_State_UD,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RU,Cache_State_UC_RSC,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_RU,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicNoReturn_PoC, {Cache_State_UD,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RU,Cache_State_UC_RSC,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_RU,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_AtomicNoReturn_PoC_Alloc, {Cache_State_UD,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_UC,Cache_State_UC_RU,Cache_State_UC_RSC,Cache_State_SD,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_RU,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_SnpCleanInvalid, {Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RSD,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD,Cache_State_UD_T}},{Cache_Event_SnpShared, {Cache_State_UD,Cache_State_UD_RSC,Cache_State_SD,Cache_State_SD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD,Cache_State_UD_T}},{Cache_Event_SnpSharedFwd, {Cache_State_UD,Cache_State_UD_RSC,Cache_State_SD,Cache_State_SD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD,Cache_State_UD_T}},{Cache_Event_SnpNotSharedDirtyFwd, {Cache_State_UD,Cache_State_UD_RSC,Cache_State_SD,Cache_State_SD_RSC,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD,Cache_State_UD_T}},{Cache_Event_SnpUnique, {Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RSD,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD,Cache_State_UD_T}},{Cache_Event_SnpUniqueFwd, {Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_RU,Cache_State_RUSD,Cache_State_RUSC,Cache_State_RSD,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_SC_RSC,Cache_State_RSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD,Cache_State_UD_T}},{Cache_Event_SnpOnce, {Cache_State_UD,Cache_State_UD_T,Cache_State_UD_RSC,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_SD,Cache_State_SD_RSC,Cache_State_SD_RSD,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD}},{Cache_Event_SnpOnceFwd, {Cache_State_UD,Cache_State_UD_T,Cache_State_UD_RSC,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_SD,Cache_State_SD_RSC,Cache_State_SD_RSD,Cache_State_UC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_SC,Cache_State_SC_RSC,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_BUSY_INTR,Cache_State_BUSY_BLKD}},{Cache_Event_SnpStalled, {Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_StashOnceShared, {Cache_State_I,Cache_State_SC,Cache_State_UC,Cache_State_SD,Cache_State_UD,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_SC_RSC,Cache_State_UC_RSC,Cache_State_SD_RSC,Cache_State_UD_RSC,Cache_State_UC_RU,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RUSC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_StashOnceUnique, {Cache_State_I,Cache_State_SC,Cache_State_UC,Cache_State_SD,Cache_State_UD,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_SC_RSC,Cache_State_UC_RSC,Cache_State_SD_RSC,Cache_State_UD_RSC,Cache_State_UC_RU,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RUSC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_DvmTlbi_Initiate, {Cache_State_I}},{Cache_Event_DvmSync_Initiate, {Cache_State_I}},{Cache_Event_SnpDvmOpSync_P1, {Cache_State_I,Cache_State_DvmExtSync_Partial}},{Cache_Event_SnpDvmOpSync_P2, {Cache_State_I,Cache_State_DvmExtSync_Partial}},{Cache_Event_SnpDvmOpNonSync_P1, {Cache_State_I,Cache_State_DvmExtTlbi_Partial}},{Cache_Event_SnpDvmOpNonSync_P2, {Cache_State_I,Cache_State_DvmExtTlbi_Partial}},{Cache_Event_Evict_Stale, {Cache_State_UD,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteBackFull_Stale, {Cache_State_UD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_UD,Cache_State_RU,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteEvictFull_Stale, {Cache_State_UD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_UD,Cache_State_RU,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_WriteCleanFull_Stale, {Cache_State_UD_RSC,Cache_State_UC_RSC,Cache_State_SC_RSC,Cache_State_SD_RSC,Cache_State_UD,Cache_State_RU,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_SD,Cache_State_UC,Cache_State_SC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_CleanUnique_Stale, {Cache_State_I,Cache_State_SC,Cache_State_UC,Cache_State_SD,Cache_State_UD,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSD,Cache_State_RUSC,Cache_State_SC_RSC,Cache_State_SD_RSD,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_UD_RU,Cache_State_UD_RSD,Cache_State_UD_RSC,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR}},{Cache_Event_Local_Eviction, {Cache_State_SC,Cache_State_UD,Cache_State_SD,Cache_State_UC,Cache_State_UC_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_SC_RSC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR,Cache_State_UD_T}},{Cache_Event_LocalHN_Eviction, {Cache_State_SC,Cache_State_UC,Cache_State_SC_RSC,Cache_State_UC_RSC,Cache_State_UC_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_UD,Cache_State_SD,Cache_State_UD_RU,Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_RU,Cache_State_RSC,Cache_State_RSD,Cache_State_RUSC,Cache_State_RUSD,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR,Cache_State_UD_T}},{Cache_Event_Global_Eviction, {Cache_State_UD_RSC,Cache_State_SD_RSC,Cache_State_UC_RSC,Cache_State_UD_RU,Cache_State_UC_RU,Cache_State_UD_RSD,Cache_State_SD_RSD,Cache_State_SC_RSC,Cache_State_I,Cache_State_BUSY_BLKD,Cache_State_BUSY_INTR,Cache_State_UD_T}}};

    for (const auto event : out_trans_evs) {
        std::string stat_name =
            "outTransLatHist." + Cache_Event_to_string(event);
        statistics::Histogram* t =
            new statistics::Histogram(&stats, stat_name.c_str());
        stats.outTransLatHist[event] = t;
        t->init(5);
        t->flags(statistics::pdf | statistics::total |
                 statistics::oneline | statistics::nozero);

        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".retries").c_str());
        stats.outTransRetryCnt[event] = r;
        r->flags(statistics::nozero);
    }

    for (const auto event : in_trans_evs) {
        std::string stat_name =
            "inTransLatHist." + Cache_Event_to_string(event);
        statistics::Histogram* t =
            new statistics::Histogram(&stats, stat_name.c_str());
        stats.inTransLatHist[event] = t;
        t->init(5);
        t->flags(statistics::pdf | statistics::total |
                 statistics::oneline | statistics::nozero);

        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".retries").c_str());
        stats.inTransRetryCnt[event] = r;
        r->flags(statistics::nozero);

        auto &src_states = stats.inTransStateChanges[event];
        for (const auto initial_state : in_trans_evs_states.at(event)) {
            auto &dst_vector = src_states[initial_state];
            for (Cache_State final_state = Cache_State_FIRST;
                 final_state < Cache_State_NUM; ++final_state) {
                std::string stat_name = "inTransLatHist." +
                    Cache_Event_to_string(event) + "." +
                    Cache_State_to_string(initial_state) + "." +
                    Cache_State_to_string(final_state) + ".total";
                statistics::Scalar* t =
                    new statistics::Scalar(&stats, stat_name.c_str());
                t->flags(statistics::nozero);
                dst_vector.push_back(t);
            }
        }
    }
}

void
Cache_Controller::collateStats()
{
    int num_controllers =
        m_ruby_system->m_num_controllers[MachineType_Cache];

    for (Cache_Event event = Cache_Event_FIRST;
         event < Cache_Event_NUM; ++event) {
        for (unsigned int i = 0; i < num_controllers; ++i) {
            RubySystem *rs = params().ruby_system;
            std::map<uint32_t, AbstractController *>::iterator it =
                     rs->m_abstract_controls[MachineType_Cache].find(i);
            assert(it != rs->m_abstract_controls[MachineType_Cache].end());
            (*eventVec[event])[i] =
                ((Cache_Controller *)(*it).second)->getEventCount(event);
        }
    }

    for (Cache_State state = Cache_State_FIRST;
         state < Cache_State_NUM; ++state) {

        for (Cache_Event event = Cache_Event_FIRST;
             event < Cache_Event_NUM; ++event) {

            for (unsigned int i = 0; i < num_controllers; ++i) {
                RubySystem *rs = params().ruby_system;
                std::map<uint32_t, AbstractController *>::iterator it =
                         rs->m_abstract_controls[MachineType_Cache].find(i);
                assert(it != rs->m_abstract_controls[MachineType_Cache].end());
                (*transVec[state][event])[i] =
                    ((Cache_Controller *)(*it).second)->getTransitionCount(state, event);
            }
        }
    }
}

void
Cache_Controller::countTransition(Cache_State state, Cache_Event event)
{
    assert(m_possible[state][event]);
    m_counters[state][event]++;
    m_event_counters[event]++;
}
void
Cache_Controller::possibleTransition(Cache_State state,
                             Cache_Event event)
{
    m_possible[state][event] = true;
}

uint64_t
Cache_Controller::getEventCount(Cache_Event event)
{
    return m_event_counters[event];
}

bool
Cache_Controller::isPossible(Cache_State state, Cache_Event event)
{
    return m_possible[state][event];
}

uint64_t
Cache_Controller::getTransitionCount(Cache_State state,
                             Cache_Event event)
{
    return m_counters[state][event];
}

MessageBuffer*
Cache_Controller::getMandatoryQueue() const
{
    return m_mandatoryQueue_ptr;
}

MessageBuffer*
Cache_Controller::getMemReqQueue() const
{
    return NULL;
}

MessageBuffer*
Cache_Controller::getMemRespQueue() const
{
    return NULL;
}

void
Cache_Controller::print(std::ostream& out) const
{
    out << "[Cache_Controller " << m_version << "]";
}

void Cache_Controller::resetStats()
{
    for (int state = 0; state < Cache_State_NUM; state++) {
        for (int event = 0; event < Cache_Event_NUM; event++) {
            m_counters[state][event] = 0;
        }
    }

    for (int event = 0; event < Cache_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }

    AbstractController::resetStats();
}

// Set and Reset for cache_entry variable
void
Cache_Controller::set_cache_entry(Cache_CacheEntry*& m_cache_entry_ptr, AbstractCacheEntry* m_new_cache_entry)
{
  m_cache_entry_ptr = (Cache_CacheEntry*)m_new_cache_entry;
  m_cache_entry_ptr->setRubySystem(m_ruby_system);
}

void
Cache_Controller::unset_cache_entry(Cache_CacheEntry*& m_cache_entry_ptr)
{
  m_cache_entry_ptr = 0;
}

// Set and Reset for tbe variable
void
Cache_Controller::set_tbe(Cache_TBE*& m_tbe_ptr, Cache_TBE* m_new_tbe)
{
  m_tbe_ptr = m_new_tbe;
}

void
Cache_Controller::unset_tbe(Cache_TBE*& m_tbe_ptr)
{
  m_tbe_ptr = NULL;
}

void
Cache_Controller::recordCacheTrace(int cntrl, CacheRecorder* tr)
{
    m_cache_ptr->recordCacheContents(cntrl, tr);
}

// Actions
/** \brief  */
void
Cache_Controller::AllocateTBE_Request(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request\n");
    try {
           if ((((*m_storTBEs_ptr)).areNSlotsAvailable((1)))) {
        (((*m_storTBEs_ptr)).incrementReserved());
        {
            // Declare message
            [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            #ifndef NDEBUG
            if (!((((*in_msg_ptr)).m_addr == addr))) {
                panic("Runtime Error at CHI-cache-actions.sm:51: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!((((*in_msg_ptr)).m_is_local_pf == (false)))) {
                panic("Runtime Error at CHI-cache-actions.sm:52: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            *out_msg = (*in_msg_ptr);
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
        }
    } else {
        {
            // Declare message
            [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!(((*in_msg_ptr)).m_allowRetry)) {
            panic("Runtime Error at CHI-cache-actions.sm:60: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
            (*out_msg).m_usesTxnId = (false);
            (*out_msg).m_event = Cache_Event_SendRetryAck;
            (*out_msg).m_retryDest = ((*in_msg_ptr)).m_requestor;
            (*out_msg).m_txnId = ((*in_msg_ptr)).m_txnId;
            (((*m_retryQueue_ptr)).emplace(((*in_msg_ptr)).m_addr, (false), ((*in_msg_ptr)).m_requestor));
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
        }
    }
    (((*m_reqIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Request: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_Request_WithCredit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request_WithCredit\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_allowRetry == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:79: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:81: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
}
(((*m_reqIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Request_WithCredit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_Snoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Snoop\n");
    try {
       (((*m_storSnpTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:97: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_snpRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(((*m_destsWaitingRetry_ptr)).remove(((*in_msg_ptr)).m_requestor));
}
(((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Snoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_DvmSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_DvmSnoop\n");
    try {
       (((*m_storDvmSnpTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    #ifndef NDEBUG
    if (!(((*in_msg_ptr)).m_usesTxnId)) {
        panic("Runtime Error at CHI-cache-actions.sm:120: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:121: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_snpRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
}
(((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_DvmSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_SeqRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_SeqRequest\n");
    try {
       (((*m_storTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_mandatoryQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = ((*in_msg_ptr)).m_LineAddress;
    #ifndef NDEBUG
    if (!(((((*in_msg_ptr)).m_Size > (0)) && (((*in_msg_ptr)).m_Size <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:139: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_PhysicalAddress;
    (*out_msg).m_accSize = ((*in_msg_ptr)).m_Size;
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch == PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:146: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (false);
    (*out_msg).m_is_remote_pf = (false);
    (*out_msg).m_txnId = m_max_outstanding_transactions;
    (*out_msg).m_ns = (! ((*in_msg_ptr)).m_isSecure);
    (((*out_msg).m_atomic_op).clear());
    (((*out_msg).m_atomic_op).orMask(((*in_msg_ptr)).m_writeMask));
        if (((((*in_msg_ptr)).m_Type == RubyRequestType_LD) || (((*in_msg_ptr)).m_Type == RubyRequestType_IFETCH))) {
            (*out_msg).m_type = CHIRequestType_Load;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_ST)) {
                        if ((((*in_msg_ptr)).m_Size == (*m_blockSize_ptr))) {
                            (*out_msg).m_type = CHIRequestType_StoreLine;
                        } else {
                            (*out_msg).m_type = CHIRequestType_Store;
                        }
                    } else {
                            if ((((*in_msg_ptr)).m_Type == RubyRequestType_ATOMIC_RETURN)) {
                                (*out_msg).m_type = CHIRequestType_AtomicLoad;
                            } else {
                                    if ((((*in_msg_ptr)).m_Type == RubyRequestType_ATOMIC_NO_RETURN)) {
                                        (*out_msg).m_type = CHIRequestType_AtomicStore;
                                    } else {
                                        panic("Runtime Error at CHI-cache-actions.sm:169: %s for machine %s.\n", ("Invalid RubyRequestType"), name());
                                        ;
                                    }
                                }
                            }
                        }
                        ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
                    }
                    }
                    (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_SeqRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_SeqDvmRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_SeqDvmRequest\n");
    try {
       (((*m_storDvmTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_mandatoryQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = ((*in_msg_ptr)).m_tlbiTransactionUid;
    (*out_msg).m_addr = ((*in_msg_ptr)).m_tlbiTransactionUid;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_tlbiTransactionUid;
    (*out_msg).m_accSize = (*m_blockSize_ptr);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch == PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:195: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (false);
    (*out_msg).m_is_remote_pf = (false);
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
        if ((((*in_msg_ptr)).m_Type == RubyRequestType_TLBI)) {
            (*out_msg).m_type = CHIRequestType_DvmTlbi_Initiate;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_TLBI_SYNC)) {
                    (*out_msg).m_type = CHIRequestType_DvmSync_Initiate;
                } else {
                        if ((((*in_msg_ptr)).m_Type == RubyRequestType_TLBI_EXT_SYNC_COMP)) {
                            (*out_msg).m_type = CHIRequestType_DvmSync_ExternCompleted;
                        } else {
                            panic("Runtime Error at CHI-cache-actions.sm:212: %s for machine %s.\n", ("Invalid RubyRequestType"), name());
                            ;
                        }
                    }
                }
                ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
            }
            }
            (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_SeqDvmRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Allocate TBE for prefetch request */
void
Cache_Controller::AllocateTBE_PfRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_PfRequest\n");
    try {
       (((*m_storTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_prefetchQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = ((*in_msg_ptr)).m_LineAddress;
    #ifndef NDEBUG
    if (!(((((*in_msg_ptr)).m_Size > (0)) && (((*in_msg_ptr)).m_Size <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:230: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_PhysicalAddress;
    (*out_msg).m_accSize = ((*in_msg_ptr)).m_Size;
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch != PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:237: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (true);
    (*out_msg).m_is_remote_pf = (false);
    (*out_msg).m_txnId = m_max_outstanding_transactions;
        if ((((*in_msg_ptr)).m_Type == RubyRequestType_LD)) {
            (*out_msg).m_type = CHIRequestType_Load;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_ST)) {
                    panic("Runtime Error at CHI-cache-actions.sm:245: %s for machine %s.\n", ("CHI is not supporting prefetch store requests"), name());
                    ;
                } else {
                    panic("Runtime Error at CHI-cache-actions.sm:247: %s for machine %s.\n", ("Invalid RubyRequestType"), name());
                    ;
                }
            }
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
        }
        (((*m_prefetchQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_PfRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateRequestTBE(addr, (*in_msg_ptr))));;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
Cache_DirEntry* dir_entry
 = (getDirEntry(addr));
(copyCacheAndDir(m_cache_entry_ptr, dir_entry, m_tbe_ptr, initial));
(*m_tbe_ptr).m_use_DMT = (m_is_HN && m_enable_DMT);
(*m_tbe_ptr).m_use_DCT = m_enable_DCT;
bool alloc_entry
 = (needCacheEntry((*m_tbe_ptr).m_reqType, m_cache_entry_ptr, dir_entry, (*m_tbe_ptr).m_is_local_pf));
bool dealloc_entry
 = (needDeallocCacheEntry((*m_tbe_ptr).m_reqType));
#ifndef NDEBUG
if (!(((alloc_entry && dealloc_entry) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:272: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_dataToBeInvalid = (dealloc_entry || ((m_cache_entry_ptr == NULL) && (alloc_entry == (false))));
(*m_tbe_ptr).m_doCacheFill = (alloc_entry || (m_cache_entry_ptr != NULL));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, was_retried));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request_DVM\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
Cache_TBE* tbe
 = (allocateDvmRequestTBE(addr, (*in_msg_ptr)));
set_tbe(m_tbe_ptr, tbe);;
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request_Stale\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateRequestTBE(addr, (*in_msg_ptr))));;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
(copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
    if ((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && (m_cache_entry_ptr != NULL))) {
        (*m_tbe_ptr).m_dataBlk = (*m_cache_entry_ptr).m_DataBlk;
        (((*m_tbe_ptr).m_dataBlkValid).fillMask());
        (*m_tbe_ptr).m_dataValid = (true);
    }
    (incomingTransactionStart(addr, (curTransitionEvent()), initial, was_retried));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Snoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Snoop\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateSnoopTBE(addr, (*in_msg_ptr))));;
}
(copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
(*m_tbe_ptr).m_dataToBeInvalid = (m_cache_entry_ptr == NULL);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Snoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Snoop_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Snoop_Hazard\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:333: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_is_req_tbe || (*m_tbe_ptr).m_is_repl_tbe))) {
    panic("Runtime Error at CHI-cache-actions.sm:334: %s for machine %s.\n", "assert failure", name());

}
#endif
;
Cache_TBE* prev_tbe
 = m_tbe_ptr;
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateSnoopTBE(addr, (*in_msg_ptr))));;
}
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:341: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*prev_tbe).m_is_req_tbe) {
        #ifndef NDEBUG
        if (!(((*prev_tbe).m_is_repl_tbe == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:343: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_req_hazard = (true);
    } else {
        #ifndef NDEBUG
        if (!((*prev_tbe).m_is_repl_tbe)) {
            panic("Runtime Error at CHI-cache-actions.sm:346: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_repl_hazard = (true);
    }
    (*m_tbe_ptr).m_pendReqType = (*prev_tbe).m_pendReqType;
    (copyCacheAndDirTBEs(prev_tbe, m_tbe_ptr));
    (*m_tbe_ptr).m_wakeup_pending_req = (*prev_tbe).m_wakeup_pending_req;
    (*m_tbe_ptr).m_wakeup_pending_snp = (*prev_tbe).m_wakeup_pending_snp;
    (*m_tbe_ptr).m_wakeup_pending_tgr = (*prev_tbe).m_wakeup_pending_tgr;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Snoop_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::RestoreFromHazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing RestoreFromHazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
(setDataToBeStates(m_tbe_ptr));
(copyCacheAndDirTBEs(m_tbe_ptr, hazard_tbe));
(*hazard_tbe).m_wakeup_pending_req = (*m_tbe_ptr).m_wakeup_pending_req;
(*hazard_tbe).m_wakeup_pending_snp = (*m_tbe_ptr).m_wakeup_pending_snp;
(*hazard_tbe).m_wakeup_pending_tgr = (*m_tbe_ptr).m_wakeup_pending_tgr;
(deallocateSnpTBE(m_tbe_ptr));
set_tbe(m_tbe_ptr, hazard_tbe);;
    if (((*m_tbe_ptr).m_pendReqType == CHIRequestType_WriteBackFull)) {
        (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false));
    } else {
            if (((*m_tbe_ptr).m_pendReqType == CHIRequestType_WriteCleanFull)) {
                (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false));
            } else {
                    if (((*hazard_tbe).m_pendReqType == CHIRequestType_WriteEvictFull)) {
                        (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false));
                    } else {
                            if (((*hazard_tbe).m_pendReqType == CHIRequestType_Evict)) {
                                (*m_tbe_ptr).m_is_stale = ((*m_tbe_ptr).m_dataValid == (false));
                            } else {
                                    if (((*hazard_tbe).m_pendReqType == CHIRequestType_CleanUnique)) {
                                        (*m_tbe_ptr).m_is_stale = ((*m_tbe_ptr).m_dataValid == (false));
                                    }
                                }
                            }
                        }
                    }
                    (wakeupPendingTgrs(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:RestoreFromHazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr == NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:392: %s for machine %s.\n", "assert failure", name());

}
#endif
;
Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
    if (m_unify_repl_TBEs) {
        {
            // Declare message
            [[maybe_unused]] const Cache_ReplacementMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const Cache_ReplacementMsg *>(((*m_replTriggerQueue_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        set_tbe(m_tbe_ptr, (allocateReplacementTBEOnSlot(addr, ((*in_msg_ptr)).m_slot)));;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:397: Allocated replacement TBE on slot %d\n", (*m_tbe_ptr).m_storSlot);
        }
    } else {
        set_tbe(m_tbe_ptr, (allocateReplacementTBE(addr)));;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:401: Allocated replacement TBE on new slot %d\n", (*m_tbe_ptr).m_storSlot);
    }
    (copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
        if ((initial == Cache_State_UD_RU)) {
            (*m_tbe_ptr).m_dataBlk = (*m_cache_entry_ptr).m_DataBlk;
            (((*m_tbe_ptr).m_dataBlkValid).fillMask());
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
        (incomingTransactionStart(addr, (curTransitionEvent()), initial, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:421: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:422: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_req = (true);
        stallBuffer(&((*m_reqRdy_ptr)), addr);
        (*m_reqRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallSnoop\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:430: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:431: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_snp = (true);
        stallBuffer(&((*m_snpRdy_ptr)), addr);
        (*m_snpRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallLocalEviction(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallLocalEviction\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:439: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:440: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_tgr = (true);
(((*m_replTriggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallLocalEviction: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallSnoop_NoTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallSnoop_NoTBE\n");
    try {
               stallBuffer(&((*m_snpRdy_ptr)), addr);
        (*m_snpRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallSnoop_NoTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallActionOnHazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallActionOnHazard\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:453: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard))) {
    panic("Runtime Error at CHI-cache-actions.sm:454: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_tgr = (true);
        stallBuffer(&((*m_triggerQueue_ptr)), addr);
        (*m_triggerQueue_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallActionOnHazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                }
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdToOwner));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpShared));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_HitUpstream_NoOwner(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_HitUpstream_NoOwner\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdToSharer));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_HitUpstream_NoOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadNoSnp\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:519: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DMT) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr == NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:524: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
        }
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadNoSnp_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadNoSnp_Hit\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:540: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadNoSnp_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_Miss\n");
    try {
       (*m_tbe_ptr).m_dataToBeInvalid = ((*m_tbe_ptr).m_doCacheFill == (false));
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr == NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:554: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                        if ((*m_tbe_ptr).m_dataToBeInvalid) {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadOnce));
                        } else {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
                        }
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                    }
                }
                (*m_tbe_ptr).m_updateDirOnCompAck = (false);
                (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnceFwd));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (*m_tbe_ptr).m_updateDirOnCompAck = (false);
        if ((m_cache_entry_ptr == NULL)) {
            (*m_tbe_ptr).m_dataToBeInvalid = (true);
        } else {
                if (((*m_tbe_ptr).m_dataValid == (false))) {
                    (*m_tbe_ptr).m_dataValid = (true);
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                }
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_AutoUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_AutoUpgrade\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:640: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_AutoUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Upgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Upgrade\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:646: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:647: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:648: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_use_DCT = (false);
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_dataMaybeDirtyUpstream) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            } else {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataValid)) {
                    panic("Runtime Error at CHI-cache-actions.sm:661: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
            }
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromRU));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Upgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
(*m_tbe_ptr).m_use_DCT = (((*m_tbe_ptr).m_use_DCT && ((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) && ((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueFwd));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
            if ((*m_tbe_ptr).m_dataMaybeDirtyUpstream) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
            }
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Hit_InvUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Hit_InvUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Hit_InvUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_MakeReadUnique_Hit_InvUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_MakeReadUnique_Hit_InvUpstream\n");
    try {
       #ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_MakeReadUnique))) {
    panic("Runtime Error at CHI-cache-actions.sm:716: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalidNoReq));
    }
        if (((! (*m_tbe_ptr).m_dataUnique) && (! m_is_HN))) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendMakeReadUnique));
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_FinishMakeReadUnique));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_MakeReadUnique_Hit_InvUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finish_MakeReadUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finish_MakeReadUnique\n");
    try {
           if (((*m_tbe_ptr).m_dataValid && ((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)))) {
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    } else {
            if ((*m_tbe_ptr).m_dataDirty) {
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompUDResp));
            } else {
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompUCResp));
            }
        }
        (*m_tbe_ptr).m_dataUnique = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dir_ownerExists = (false);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finish_MakeReadUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CleanUnique\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalidNoReq));
    }
    (*m_tbe_ptr).m_dataUnique = ((*m_tbe_ptr).m_dataUnique || m_is_HN);
        if (((*m_tbe_ptr).m_dataUnique == (false))) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromCU));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_FinishCleanUnique));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CleanUnique_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CleanUnique_Stale\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCRespStale));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CleanUnique_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finish_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finish_CleanUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:780: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false))) {
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:785: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_is_stale)) {
            panic("Runtime Error at CHI-cache-actions.sm:786: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_stale = (false);
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCRespStale));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
            panic("Runtime Error at CHI-cache-actions.sm:793: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataUnique)) {
            panic("Runtime Error at CHI-cache-actions.sm:794: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dir_ownerExists = (false);
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCResp));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finish_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_LoadHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_LoadHit\n");
    try {
           if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_LoadHit));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_LoadHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_LoadMiss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_LoadMiss\n");
    try {
           if ((*m_tbe_ptr).m_doCacheFill) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadOnce));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_LoadMiss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreHit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_StoreHit));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreMiss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreMiss\n");
    try {
           if ((*m_tbe_ptr).m_doCacheFill) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUDataCB));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreMiss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Atomic_UC(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Atomic_UC\n");
    try {
           if ((((m_policy_type == (0)) || (m_policy_type == (1))) || (m_policy_type == (2)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_AtomicHit));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayWrite));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
    } else {
        panic("Runtime Error at CHI-cache-actions.sm:863: %s for machine %s.\n", ("Invalid policy type"), name());
        ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Atomic_UC: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Atomic_UD(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Atomic_UD\n");
    try {
           if ((((m_policy_type == (0)) || (m_policy_type == (1))) || (m_policy_type == (2)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_AtomicHit));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayWrite));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
    } else {
        panic("Runtime Error at CHI-cache-actions.sm:878: %s for machine %s.\n", ("Invalid policy type"), name());
        ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Atomic_UD: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_I(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_I\n");
    try {
           if ((m_policy_type == (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
        (*m_tbe_ptr).m_atomic_to_be_done = (true);
    } else {
            if (((m_policy_type == (1)) || (m_policy_type == (2)))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicReturn));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendARData));
                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                (*m_tbe_ptr).m_doCacheFill = (false);
                (*m_tbe_ptr).m_atomic_to_be_done = (false);
            } else {
                panic("Runtime Error at CHI-cache-actions.sm:898: %s for machine %s.\n", ("Invalid policy type"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_I: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_I(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_I\n");
    try {
           if ((m_policy_type == (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
        (*m_tbe_ptr).m_atomic_to_be_done = (true);
    } else {
            if (((m_policy_type == (1)) || (m_policy_type == (2)))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicNoReturn));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendANRData));
                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                (*m_tbe_ptr).m_doCacheFill = (false);
                (*m_tbe_ptr).m_atomic_to_be_done = (false);
            } else {
                panic("Runtime Error at CHI-cache-actions.sm:918: %s for machine %s.\n", ("Invalid policy type"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_I: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_SD(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_SD\n");
    try {
           if (((m_policy_type == (0)) || (m_policy_type == (2)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
        (*m_tbe_ptr).m_atomic_to_be_done = (true);
    } else {
            if ((m_policy_type == (1))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicReturn));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendARData));
                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                (*m_tbe_ptr).m_doCacheFill = (false);
                (*m_tbe_ptr).m_atomic_to_be_done = (false);
            } else {
                panic("Runtime Error at CHI-cache-actions.sm:938: %s for machine %s.\n", ("Invalid policy type"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_SD: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_SD(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_SD\n");
    try {
           if (((m_policy_type == (0)) || (m_policy_type == (2)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
        (*m_tbe_ptr).m_atomic_to_be_done = (true);
    } else {
            if ((m_policy_type == (1))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicNoReturn));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendANRData));
                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                (*m_tbe_ptr).m_doCacheFill = (false);
                (*m_tbe_ptr).m_atomic_to_be_done = (false);
            } else {
                panic("Runtime Error at CHI-cache-actions.sm:958: %s for machine %s.\n", ("Invalid policy type"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_SD: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_SC(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_SC\n");
    try {
           if (((m_policy_type == (0)) || (m_policy_type == (2)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
        (*m_tbe_ptr).m_atomic_to_be_done = (true);
    } else {
            if ((m_policy_type == (1))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicReturn));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendARData));
                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                (*m_tbe_ptr).m_doCacheFill = (false);
                (*m_tbe_ptr).m_atomic_to_be_done = (false);
            } else {
                panic("Runtime Error at CHI-cache-actions.sm:978: %s for machine %s.\n", ("Invalid policy type"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_SC: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_SC(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_SC\n");
    try {
           if (((m_policy_type == (0)) || (m_policy_type == (2)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
        (*m_tbe_ptr).m_atomic_to_be_done = (true);
    } else {
            if ((m_policy_type == (1))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicNoReturn));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendANRData));
                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                (*m_tbe_ptr).m_doCacheFill = (false);
                (*m_tbe_ptr).m_atomic_to_be_done = (false);
            } else {
                panic("Runtime Error at CHI-cache-actions.sm:998: %s for machine %s.\n", ("Invalid policy type"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_SC: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreUpgrade\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:1003: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1004: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromStore));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Zero(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Zero\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1012: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteZero));
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WUZ));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Zero: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_LocalWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_LocalWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN || (*m_tbe_ptr).m_dataUnique))) {
    panic("Runtime Error at CHI-cache-actions.sm:1032: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_LocalWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_LocalWrite_AfterUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_LocalWrite_AfterUpgrade\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1050: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1051: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
    if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_LocalWrite_AfterUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Writeback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Writeback\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1066: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1067: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnp));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnp));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
    (*m_tbe_ptr).m_dataToBeInvalid = (true);
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Writeback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_PartialWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_PartialWrite\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1086: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnpPartial));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnpPartial));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_PartialWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Forward(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Forward\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteUnique));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Forward: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_LocalWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_LocalWrite\n");
    try {
           if ((((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) && (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            }
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_AR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompData_AR));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_LocalWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_WriteBack(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_WriteBack\n");
    try {
           if ((((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) && (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            }
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_AR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompData_AR));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_WriteBack: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_LocalWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_LocalWrite\n");
    try {
           if ((((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) && (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            }
        }
            if (m_comp_anr) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_ANR));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_ANR));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_ANR));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_LocalWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_WriteBack(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_WriteBack\n");
    try {
           if ((((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) && (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            }
        }
            if (m_comp_anr) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_ANR));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_ANR));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_ANR));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
            (*m_tbe_ptr).m_dataToBeInvalid = (true);
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_WriteBack: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_Forward(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_Forward\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicReturn));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_AR));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendARData));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompData_AR));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
(*m_tbe_ptr).m_dataToBeInvalid = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_Forward: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_Forward(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_Forward\n");
    try {
           if (m_comp_anr) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicNoReturn));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_ANR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_ANR));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendAtomicNoReturn));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_ANR));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendANRData));
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
    (*m_tbe_ptr).m_dataToBeInvalid = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_Forward: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_Miss_Alloc(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_Miss_Alloc\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_AR));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompData_AR));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_Miss_Alloc: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicReturn_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicReturn_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_AR));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompData_AR));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicReturn_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_Miss_Alloc(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_Miss_Alloc\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1250: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
    if (m_comp_anr) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_ANR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_ANR));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_ANR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_Miss_Alloc: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_AtomicNoReturn_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_AtomicNoReturn_Miss\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1268: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
    if (m_comp_anr) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_ANR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_ANR));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_ANR));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_DelayAtomic));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
    (*m_tbe_ptr).m_dataToBeInvalid = (true);
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_AtomicNoReturn_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CopyBack(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CopyBack\n");
    try {
           if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteBackFull)) {
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UD_PD));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SD_PD));
    } else {
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteEvictFull)) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_WriteEvictFull))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1292: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UC));
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SC));
            } else {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_WriteCleanFull))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1296: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UD_PD));
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SD_PD));
            }
        }
        (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompDBIDResp));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CopyBack: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CopyBack_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CopyBack_Stale\n");
    try {
       (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_I));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompDBIDRespStale));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_FinishCopyBack_Stale));
    }
    #ifndef NDEBUG
    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != (*m_tbe_ptr).m_requestor)))) {
        panic("Runtime Error at CHI-cache-actions.sm:1321: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CopyBack_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finish_CopyBack_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finish_CopyBack_Stale\n");
    try {
           if ((((m_is_HN == (false)) && ((((*m_tbe_ptr).m_dir_sharers).count()) == (0))) && ((*m_tbe_ptr).m_dataValid == (false)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finish_CopyBack_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Evict\n");
    try {
           if ((((m_is_HN == (false)) && ((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) && ((*m_tbe_ptr).m_dataValid == (false)))) {
            if ((*m_tbe_ptr).m_dataUnique) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
            }
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_MaintainCoherence(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_MaintainCoherence\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1359: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataToBeInvalid)) {
        bool has_non_ex_owner
         = ((*m_tbe_ptr).m_dir_ownerExists && (! (*m_tbe_ptr).m_dir_ownerIsExcl));
            if (m_is_HN) {
                    if (((*m_tbe_ptr).m_dataDirty && (! has_non_ex_owner))) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                    }
                } else {
                        if (((((*m_tbe_ptr).m_dir_sharers).isEmpty()) && ((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique))) {
                            #ifndef NDEBUG
                            if (!((! has_non_ex_owner))) {
                                panic("Runtime Error at CHI-cache-actions.sm:1373: %s for machine %s.\n", "assert failure", name());

                            }
                            #endif
                            ;
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                        } else {
                                if (((*m_tbe_ptr).m_dataDirty && (! has_non_ex_owner))) {
                                    #ifndef NDEBUG
                                    if (!((! (((*m_tbe_ptr).m_dir_sharers).isEmpty())))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:1378: %s for machine %s.\n", "assert failure", name());

                                    }
                                    #endif
                                    ;
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                                }
                            }
                        }
                    } else {
                            if ((*m_tbe_ptr).m_dataValid) {
                                (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                            }
                        }
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_MaintainCoherence: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_InvalidationSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_InvalidationSnoop\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpInvPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
            if ((((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd) || ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique))) {
                    if ((((*m_tbe_ptr).m_snpNeedsData && ((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false))) || ((*m_tbe_ptr).m_dataValid == (false)))) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
                    } else {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
                    }
                } else {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpCleanInvalid))) {
                        panic("Runtime Error at CHI-cache-actions.sm:1407: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
                }
            }
                if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd)) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueFwdCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendInvSnpResp));
                }
                    if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
                    } else {
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
                    }
                    (*m_tbe_ptr).m_dataToBeInvalid = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_InvalidationSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_SnpShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_SnpShared\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpSharedPipe));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
            panic("Runtime Error at CHI-cache-actions.sm:1431: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpShared));
    } else {
            if (((*m_tbe_ptr).m_dataValid == (false))) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1435: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1436: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
            }
        }
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpSharedFwd)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdCompData));
            } else {
                    if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpNotSharedDirtyFwd)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpNotSharedDirtyFwdCompData));
                    } else {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpShared))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1447: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpData));
                    }
                }
                    if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
                    } else {
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
                    }
                    (*m_tbe_ptr).m_dataToBeSharedClean = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_SnpShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_SnpOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_SnpOnce\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpOncePipe));
    if (((*m_tbe_ptr).m_dataValid == (false))) {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-actions.sm:1461: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
    }
        if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnceFwd)) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnceFwdCompData));
        } else {
            #ifndef NDEBUG
            if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnce))) {
                panic("Runtime Error at CHI-cache-actions.sm:1470: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!((*m_tbe_ptr).m_snpNeedsData)) {
                panic("Runtime Error at CHI-cache-actions.sm:1471: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpData));
        }
            if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
            } else {
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_SnpOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_Evict_BackInvalidte(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_Evict_BackInvalidte\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1485: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_Evict_BackInvalidte: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_Evict\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1493: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1494: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_JustDrop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_JustDrop\n");
    try {
       (*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_JustDrop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_WB_BackInvalidate(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_WB_BackInvalidate\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) || (*m_tbe_ptr).m_dataMaybeDirtyUpstream))) {
    panic("Runtime Error at CHI-cache-actions.sm:1506: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
    if (m_is_HN) {
            if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
            }
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_WB_BackInvalidate: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_WB(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_WB\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
    if (m_is_HN) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataDirty)) {
            panic("Runtime Error at CHI-cache-actions.sm:1527: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
    } else {
            if ((((*m_tbe_ptr).m_dir_sharers).isEmpty())) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1530: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
            } else {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataDirty)) {
                    panic("Runtime Error at CHI-cache-actions.sm:1533: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
            }
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_WB: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadShared\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1546: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1547: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_SC));
    if (m_allow_SD) {
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_SD_PD));
    }
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
    (((*m_tbe_ptr).m_dataBlkValid).clear());
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            if (m_allow_SD) {
                (prepareRequest(m_tbe_ptr, CHIRequestType_ReadShared, *out_msg));
            } else {
                (prepareRequest(m_tbe_ptr, CHIRequestType_ReadNotSharedDirty, *out_msg));
            }
            (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
            (*out_msg).m_dataToFwdRequestor = (false);
            (allowRequestRetry(m_tbe_ptr, *out_msg));
            ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadNoSnp\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1575: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_use_DMT == (false)) || (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicReturn) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicNoReturn))))) {
    panic("Runtime Error at CHI-cache-actions.sm:1578: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
(((*m_tbe_ptr).m_dataBlkValid).clear());
(outgoingTransactionStart(addr, (curTransitionEvent())));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadNoSnp, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadNoSnpDMT(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadNoSnpDMT\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1597: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_use_DMT)) {
    panic("Runtime Error at CHI-cache-actions.sm:1598: %s for machine %s.\n", "assert failure", name());

}
#endif
;
CHIRequestType req
 = CHIRequestType_ReadNoSnp;
    if (m_enable_DMT_early_dealloc) {
        req = CHIRequestType_ReadNoSnpSep;
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_ReadReceipt));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
    }
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
        (prepareRequest(m_tbe_ptr, req, *out_msg));
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (*out_msg).m_dataToFwdRequestor = (true);
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadNoSnpDMT: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadOnce\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1616: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1617: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_I));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
(((*m_tbe_ptr).m_dataBlkValid).clear());
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadOnce, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1637: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1639: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_MakeReadUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_MakeReadUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1657: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1659: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_MakeReadUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_MakeReadUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CleanUnique\n");
    try {
       #ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid || ((((*m_tbe_ptr).m_dir_sharers).count()) > (0))))) {
    panic("Runtime Error at CHI-cache-actions.sm:1679: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1680: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1682: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_UC));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_CleanUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Evict\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1695: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1696: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1697: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_Evict, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_I));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_InvSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_InvSnpResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1709: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1710: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_snpNeedsData) || ((*m_tbe_ptr).m_dataUnique && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique)))) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpData));
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpIResp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_InvSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteBackOrWriteEvict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteBackOrWriteEvict\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1720: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1721: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid || (((*m_tbe_ptr).m_dir_ownerIsExcl && (*m_tbe_ptr).m_dataUnique) && (*m_tbe_ptr).m_dataDirty)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1723: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1724: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique || (*m_tbe_ptr).m_dataDirty))) {
    panic("Runtime Error at CHI-cache-actions.sm:1726: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1727: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
        if ((*m_tbe_ptr).m_dataDirty) {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteBackFull, *out_msg));
        } else {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteEvictFull, *out_msg));
        }
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }
    (clearExpectedReqResp(m_tbe_ptr));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteBackOrWriteEvict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteCleanFull(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteCleanFull\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1744: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1745: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid || (((*m_tbe_ptr).m_dir_ownerIsExcl && (*m_tbe_ptr).m_dataUnique) && (*m_tbe_ptr).m_dataDirty)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1748: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1749: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataDirty)) {
    panic("Runtime Error at CHI-cache-actions.sm:1750: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteCleanFull, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteCleanFull: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteNoSnp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1763: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteNoSnp, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
(*m_tbe_ptr).m_atomic_to_be_wb = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteNoSnp_Partial(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteNoSnp_Partial\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1780: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteNoSnpPtl, *out_msg));
    (*out_msg).m_accAddr = (*m_tbe_ptr).m_accAddr;
    (*out_msg).m_accSize = (*m_tbe_ptr).m_accSize;
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteNoSnp_Partial: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1796: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
        if (((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr))) {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteUniqueFull, *out_msg));
        } else {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteUniquePtl, *out_msg));
            (*out_msg).m_accAddr = (*m_tbe_ptr).m_accAddr;
            (*out_msg).m_accSize = (*m_tbe_ptr).m_accSize;
        }
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_AtomicReturn(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_AtomicReturn\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1818: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequestAtomic(m_tbe_ptr, CHIRequestType_AtomicReturn, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_AtomicReturn: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_AtomicNoReturn(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_AtomicNoReturn\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1831: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequestAtomic(m_tbe_ptr, CHIRequestType_AtomicNoReturn, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_AtomicNoReturn: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpCleanInvalid(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpCleanInvalid\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1845: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1846: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1848: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpCleanInvalid, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(setExpectedForInvSnoop(m_tbe_ptr, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpCleanInvalid: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpCleanInvalid_NoReq(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpCleanInvalid_NoReq\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1859: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1860: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpCleanInvalid, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (((*out_msg).m_Destination).remove((*m_tbe_ptr).m_requestor));
    #ifndef NDEBUG
    if (!(((((*out_msg).m_Destination).count()) > (0)))) {
        panic("Runtime Error at CHI-cache-actions.sm:1866: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*out_msg).m_retToSrc = (false);
    (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
    (setExpectedForInvSnoop(m_tbe_ptr, (false)));
    (((*m_tbe_ptr).m_expected_snp_resp).setExpectedCount((((*out_msg).m_Destination).count())));
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpCleanInvalid_NoReq: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1875: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1877: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(setExpectedForInvSnoop(m_tbe_ptr, (true)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUnique_RetToSrc(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUnique_RetToSrc\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1890: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1892: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(setExpectedForInvSnoop(m_tbe_ptr, (true)));
MachineID dest;
    if ((*m_tbe_ptr).m_dir_ownerExists) {
        dest = (*m_tbe_ptr).m_dir_owner;
    } else {
        dest = (((*m_tbe_ptr).m_dir_sharers).smallestElement());
    }
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
        (((*out_msg).m_Destination).add(dest));
        (*out_msg).m_retToSrc = (true);
        (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }
        if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
            {
                std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
                (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
                (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
                (((*out_msg).m_Destination).remove(dest));
                (*out_msg).m_retToSrc = (false);
                (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUnique_RetToSrc: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUniqueFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUniqueFwd\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1922: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1924: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1926: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I_Fwded_UC));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I_Fwded_UD_PD));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUniqueFwd, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUniqueFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpShared\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1941: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
    panic("Runtime Error at CHI-cache-actions.sm:1944: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dir_ownerExists)) {
    panic("Runtime Error at CHI-cache-actions.sm:1945: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1946: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1948: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_PD));
(((*m_tbe_ptr).m_expected_snp_resp).setExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpShared, *out_msg));
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
    (*out_msg).m_retToSrc = (false);
    (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpSharedFwd_ToOwner(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpSharedFwd_ToOwner\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1963: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
    panic("Runtime Error at CHI-cache-actions.sm:1966: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dir_ownerExists)) {
    panic("Runtime Error at CHI-cache-actions.sm:1967: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1968: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1970: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
bool allowFwdSD
 = ((*m_tbe_ptr).m_reqType != CHIRequestType_ReadNotSharedDirty);
bool retToSrc
 = ((*m_tbe_ptr).m_doCacheFill && ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
    if (allowFwdSD) {
            if (retToSrc) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SD_PD));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SD_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SD_PD));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SD_PD));
            }
        } else {
                if (retToSrc) {
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
                } else {
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
                }
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_PD_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SD_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_PD_Fwded_SC));
            }
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
            {
                std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
                    if (allowFwdSD) {
                        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpSharedFwd, *out_msg));
                    } else {
                        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpNotSharedDirtyFwd, *out_msg));
                    }
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                    (*out_msg).m_retToSrc = retToSrc;
                    (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
                    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
                }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpSharedFwd_ToOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpSharedFwd_ToSharer(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpSharedFwd_ToSharer\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2015: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2017: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2018: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2019: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2021: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
bool retToSrc
 = (*m_tbe_ptr).m_doCacheFill;
    if (retToSrc) {
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
    } else {
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
    }
    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpSharedFwd, *out_msg));
        (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
        (*out_msg).m_retToSrc = retToSrc;
        (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpSharedFwd_ToSharer: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpOnce\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2044: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2047: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2049: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
            if ((*m_tbe_ptr).m_dir_ownerIsExcl) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_UC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_UD));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SD));
            }
        } else {
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC));
        }
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            (prepareRequest(m_tbe_ptr, CHIRequestType_SnpOnce, *out_msg));
                if ((*m_tbe_ptr).m_dir_ownerExists) {
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                } else {
                    (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
                }
                (*out_msg).m_retToSrc = (true);
                (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpOnceFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpOnceFwd\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2078: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2081: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2083: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
            if ((*m_tbe_ptr).m_dir_ownerIsExcl) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_UC_Fwded_I));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_UD_Fwded_I));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SD_Fwded_I));
            }
        } else {
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_I));
        }
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            (prepareRequest(m_tbe_ptr, CHIRequestType_SnpOnceFwd, *out_msg));
                if ((*m_tbe_ptr).m_dir_ownerExists) {
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                } else {
                    (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
                }
                (*out_msg).m_retToSrc = (false);
                (*out_msg).m_ns = (*m_tbe_ptr).m_ns;
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpOnceFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectNCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectNCBWrData\n");
    try {
       int num_msgs
 = ((*m_tbe_ptr).m_accSize / m_data_channel_size);
    if ((((*m_tbe_ptr).m_accSize % m_data_channel_size) != (0))) {
        num_msgs = (num_msgs + (1));
    }
    (((*m_tbe_ptr).m_expected_req_resp).clear(num_msgs));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_NCBWrData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
    (((*m_tbe_ptr).m_dataBlkValid).setMask((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)), (*m_tbe_ptr).m_accSize, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectNCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectNCBWrData_A(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectNCBWrData_A\n");
    try {
       int num_msgs
 = ((*m_tbe_ptr).m_accSize / m_data_channel_size);
    if ((((*m_tbe_ptr).m_accSize % m_data_channel_size) != (0))) {
        num_msgs = (num_msgs + (1));
    }
    (((*m_tbe_ptr).m_expected_req_resp).clear(num_msgs));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_NCBWrData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectNCBWrData_A: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectCompAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectCompAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2141: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompAck));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectCompAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2147: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteZero(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteZero\n");
    try {
       (((*m_tbe_ptr).m_dataBlkValid).fillMask());
(((*m_tbe_ptr).m_dataBlk).clear());

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteZero: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2158: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2159: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2163: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }
        if (((((*in_msg_ptr)).m_type == CHIDataType_NCBWrData) && (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicReturn) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicNoReturn)))) {
        } else {
                if (((((*in_msg_ptr)).m_type == CHIDataType_CompData_I) && (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicReturn) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicLoad)))) {
                        if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                            (((*m_tbe_ptr).m_dataBlkValid).clear());
                        }
                        (((*m_tbe_ptr).m_oldDataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                        #ifndef NDEBUG
                        if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2178: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2180: Received %s\n", (*m_tbe_ptr).m_oldDataBlk);
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2181: dataBlkValid = %s\n", (*m_tbe_ptr).m_dataBlkValid);
                    } else {
                            if ((((((((((*m_tbe_ptr).m_dataBlkValid).isFull()) == (false)) || (((*in_msg_ptr)).m_type == CHIDataType_CompData_UD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CompData_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_NCBWrData))) {
                                    if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                                        (((*m_tbe_ptr).m_dataBlkValid).clear());
                                    }
                                    (((*m_tbe_ptr).m_dataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                                    #ifndef NDEBUG
                                    if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:2193: %s for machine %s.\n", "assert failure", name());

                                    }
                                    #endif
                                    ;
                                    (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
                                }
                            }
                        }
                        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RespSepDataFromCompData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RespSepDataFromCompData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2200: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2201: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receivedRespType(CHIResponseType_RespSepData)) == (false))) {
            if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_RespSepData)) == (false))) {
                panic("Runtime Error at CHI-cache-actions.sm:2205: %s for machine %s.\n", ("Received unexpected message"), name());
                ;
            }
                if ((((m_is_HN == (false)) && ((*m_tbe_ptr).m_reqType != CHIRequestType_AtomicReturn)) && (((*m_tbe_ptr).m_reqType != CHIRequestType_AtomicLoad) || ((*m_tbe_ptr).m_atomic_to_be_done == (true))))) {
                    (((*m_tbe_ptr).m_actions).pushFrontNB(Cache_Event_SendCompAck));
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RespSepDataFromCompData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RespSepData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RespSepData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2216: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2217: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_RespSepData)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2219: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }
        if ((m_is_HN == (false))) {
            (((*m_tbe_ptr).m_actions).pushFrontNB(Cache_Event_SendCompAck));
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RespSepData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReadReceipt(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReadReceipt\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2228: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2229: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_ReadReceipt)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2231: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReadReceipt: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_SnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2236: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2237: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2241: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }
        if (((((((((((*m_tbe_ptr).m_dataBlkValid).isFull()) == (false)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC))) {
                if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                    (((*m_tbe_ptr).m_dataBlkValid).clear());
                }
                (((*m_tbe_ptr).m_dataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2257: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
            }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_SnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2264: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2267: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UC)) {
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2271: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2272: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) {
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2278: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2279: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_reqType != CHIRequestType_WriteCleanFull)) {
                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                            }
                        } else {
                                if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SC)) {
                                    #ifndef NDEBUG
                                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:2287: %s for machine %s.\n", "assert failure", name());

                                    }
                                    #endif
                                    ;
                                        if (((*m_tbe_ptr).m_reqType != CHIRequestType_WriteCleanFull)) {
                                            (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                        }
                                    } else {
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_ownerIsExcl == (false))) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2294: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2295: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                                    if (((*m_tbe_ptr).m_reqType != CHIRequestType_WriteCleanFull)) {
                                                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                                    }
                                                } else {
                                                        if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_I)) {
                                                            #ifndef NDEBUG
                                                            if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:2304: %s for machine %s.\n", "assert failure", name());

                                                            }
                                                            #endif
                                                            ;
                                                            #ifndef NDEBUG
                                                            if (!(((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)) == (false)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:2305: %s for machine %s.\n", "assert failure", name());

                                                            }
                                                            #endif
                                                            ;
                                                        } else {
                                                            panic("Runtime Error at CHI-cache-actions.sm:2308: %s for machine %s.\n", ("Unsuported data type"), name());
                                                            ;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        }
                                    }
                                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromSnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromSnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2316: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_snp_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2319: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I)) {
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2323: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD)) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2329: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2330: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dir_ownerExists = (false);
                        (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                    } else {
                            if (((((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD_Fwded_SC))) {
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:2343: %s for machine %s.\n", "assert failure", name());

                                }
                                #endif
                                ;
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:2344: %s for machine %s.\n", "assert failure", name());

                                }
                                #endif
                                ;
                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                    if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD_Fwded_SC))) {
                                        (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                    }
                                        if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) {
                                            (*m_tbe_ptr).m_dir_ownerExists = (true);
                                            (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                        } else {
                                                if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD_Fwded_SC)) {
                                                    (*m_tbe_ptr).m_dir_ownerExists = (true);
                                                    (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                                                }
                                            }
                                        } else {
                                                if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SC))) {
                                                    #ifndef NDEBUG
                                                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                                        panic("Runtime Error at CHI-cache-actions.sm:2366: %s for machine %s.\n", "assert failure", name());

                                                    }
                                                    #endif
                                                    ;
                                                    #ifndef NDEBUG
                                                    if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                        panic("Runtime Error at CHI-cache-actions.sm:2367: %s for machine %s.\n", "assert failure", name());

                                                    }
                                                    #endif
                                                    ;
                                                    (*m_tbe_ptr).m_dir_ownerExists = (false);
                                                    (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                                    (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                                    (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                                        if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) {
                                                            (*m_tbe_ptr).m_dir_ownerExists = (true);
                                                            (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                                        }
                                                    } else {
                                                            if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD))) {
                                                                #ifndef NDEBUG
                                                                if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                                    panic("Runtime Error at CHI-cache-actions.sm:2382: %s for machine %s.\n", "assert failure", name());

                                                                }
                                                                #endif
                                                                ;
                                                                #ifndef NDEBUG
                                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                                    panic("Runtime Error at CHI-cache-actions.sm:2383: %s for machine %s.\n", "assert failure", name());

                                                                }
                                                                #endif
                                                                ;
                                                            } else {
                                                                panic("Runtime Error at CHI-cache-actions.sm:2386: %s for machine %s.\n", ("Unsuported data type"), name());
                                                                ;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            }
                                        }
                                        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromSnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2394: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2397: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (((((*in_msg_ptr)).m_type == CHIDataType_CompData_UC) || (((*in_msg_ptr)).m_type == CHIDataType_DataSepResp_UC))) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2402: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2403: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (*m_tbe_ptr).m_dataDirty = (false);
                (*m_tbe_ptr).m_dataUnique = (true);
                (*m_tbe_ptr).m_dataValid = (true);
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2407: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_UD_PD)) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2410: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2411: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dataDirty = (true);
                        (*m_tbe_ptr).m_dataUnique = (true);
                        (*m_tbe_ptr).m_dataValid = (true);
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2415: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                    } else {
                            if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_SC)) {
                                #ifndef NDEBUG
                                if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:2418: %s for machine %s.\n", "assert failure", name());

                                }
                                #endif
                                ;
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:2419: %s for machine %s.\n", "assert failure", name());

                                }
                                #endif
                                ;
                                (*m_tbe_ptr).m_dataDirty = (false);
                                (*m_tbe_ptr).m_dataUnique = (false);
                                (*m_tbe_ptr).m_dataValid = (true);
                                #ifndef NDEBUG
                                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:2423: %s for machine %s.\n", "assert failure", name());

                                }
                                #endif
                                ;
                            } else {
                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_SD_PD)) {
                                        #ifndef NDEBUG
                                        if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2426: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2427: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        (*m_tbe_ptr).m_dataDirty = (true);
                                        (*m_tbe_ptr).m_dataUnique = (false);
                                        (*m_tbe_ptr).m_dataValid = (true);
                                        #ifndef NDEBUG
                                        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2431: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                    } else {
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_I)) {
                                                (*m_tbe_ptr).m_dataValid = (true);
                                                (*m_tbe_ptr).m_dataAMOValid = (true);
                                                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                                                #ifndef NDEBUG
                                                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2437: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UC)) {
                                                        #ifndef NDEBUG
                                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:2440: %s for machine %s.\n", "assert failure", name());

                                                        }
                                                        #endif
                                                        ;
                                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                        (*m_tbe_ptr).m_dataValid = (true);
                                                    } else {
                                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SC)) {
                                                            } else {
                                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) {
                                                                        #ifndef NDEBUG
                                                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                                                            panic("Runtime Error at CHI-cache-actions.sm:2448: %s for machine %s.\n", "assert failure", name());

                                                                        }
                                                                        #endif
                                                                        ;
                                                                        (*m_tbe_ptr).m_dataDirty = (true);
                                                                        (*m_tbe_ptr).m_dataValid = (true);
                                                                            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteCleanFull)) {
                                                                                #ifndef NDEBUG
                                                                                if (!(((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl))) {
                                                                                    panic("Runtime Error at CHI-cache-actions.sm:2453: %s for machine %s.\n", "assert failure", name());

                                                                                }
                                                                                #endif
                                                                                ;
                                                                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                                                                            } else {
                                                                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                                            }
                                                                        } else {
                                                                                if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) {
                                                                                    (*m_tbe_ptr).m_dataDirty = (true);
                                                                                    (*m_tbe_ptr).m_dataValid = (true);
                                                                                    (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                                                } else {
                                                                                        if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_I)) {
                                                                                        } else {
                                                                                            panic("Runtime Error at CHI-cache-actions.sm:2468: %s for machine %s.\n", ("Unsuported data type"), name());
                                                                                            ;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    }
                                                }
                                                (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromWUDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromWUDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2476: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData()) && ((*m_tbe_ptr).m_reqType != CHIRequestType_AtomicReturn)) && ((*m_tbe_ptr).m_reqType != CHIRequestType_AtomicNoReturn))) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).test((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)))))) {
            panic("Runtime Error at CHI-cache-actions.sm:2480: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).test((((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)) + (*m_tbe_ptr).m_accSize) - (1)))))) {
            panic("Runtime Error at CHI-cache-actions.sm:2482: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!((((*in_msg_ptr)).m_type == CHIDataType_NCBWrData))) {
            panic("Runtime Error at CHI-cache-actions.sm:2484: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_dataDirty = (true);
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteUniquePtl)) {
                (*m_tbe_ptr).m_dataValid = ((*m_tbe_ptr).m_dataValid || ((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr)));
            } else {
                (*m_tbe_ptr).m_dataValid = ((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr));
            }
            }
        }
        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromWUDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromADataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromADataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2498: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((m_is_HN && (((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) && (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicReturn) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicNoReturn)))) {
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2502: Atomic before %s\n", (*m_tbe_ptr).m_dataBlk);
        (*m_tbe_ptr).m_oldDataBlk = (*m_tbe_ptr).m_dataBlk;
        (((*m_tbe_ptr).m_dataBlk).atomicPartial((*m_tbe_ptr).m_dataBlk, (*m_tbe_ptr).m_atomic_op));
        (((*m_tbe_ptr).m_dataBlk).clearAtomicLogEntries());
        (*m_tbe_ptr).m_dataDirty = (true);
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2509: Atomic after %s\n", (*m_tbe_ptr).m_dataBlk);
    } else {
            if (((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData()) && (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicReturn) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicNoReturn)))) {
                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
            }
        }
        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromADataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromCUResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromCUResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2519: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_type == CHIResponseType_Comp_UC))) {
    panic("Runtime Error at CHI-cache-actions.sm:2521: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2522: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_dataUnique = ((*m_tbe_ptr).m_dataValid || ((((*m_tbe_ptr).m_dir_sharers).count()) > (0)));
}
(printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromCUResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromSnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromSnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2531: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_snp_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2534: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC))) {
                (*m_tbe_ptr).m_dataDirty = (true);
                (*m_tbe_ptr).m_dataValid = (true);
                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
            } else {
                    if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD_Fwded_SC))) {
                        (*m_tbe_ptr).m_dataDirty = (true);
                        (*m_tbe_ptr).m_dataValid = (true);
                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                    } else {
                            if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SC))) {
                                (*m_tbe_ptr).m_dataValid = (true);
                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                            } else {
                                    if (((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UC) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD))) {
                                        (*m_tbe_ptr).m_dataValid = (true);
                                        (*m_tbe_ptr).m_dataUnique = (true);
                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD)) {
                                                (*m_tbe_ptr).m_dataDirty = (true);
                                            }
                                        } else {
                                            panic("Runtime Error at CHI-cache-actions.sm:2570: %s for machine %s.\n", ("Unsuported data type"), name());
                                            ;
                                        }
                                    }
                                }
                            }
                            }
                        }
                        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromSnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromReqResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromReqResp\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*in_msg_ptr)).m_type == CHIResponseType_CompAck) && (*m_tbe_ptr).m_updateDirOnCompAck)) {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_requestor == ((*in_msg_ptr)).m_responder))) {
            panic("Runtime Error at CHI-cache-actions.sm:2580: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).add(((*in_msg_ptr)).m_responder));
            if ((*m_tbe_ptr).m_requestorToBeOwner) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                    panic("Runtime Error at CHI-cache-actions.sm:2585: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2586: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_requestorToBeExclusiveOwner == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2587: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                (*m_tbe_ptr).m_dir_ownerExists = (true);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
            } else {
                    if ((*m_tbe_ptr).m_requestorToBeExclusiveOwner) {
                        #ifndef NDEBUG
                        if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                            panic("Runtime Error at CHI-cache-actions.sm:2593: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2594: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2595: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                        (*m_tbe_ptr).m_dir_ownerIsExcl = (true);
                    }
                }
            }
            }
            (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromReqResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromSnpResp\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I)) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2610: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            if (((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))) {
                (*m_tbe_ptr).m_dir_ownerExists = (false);
            }
        } else {
                if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC)) {
                    #ifndef NDEBUG
                    if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2618: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                    #ifndef NDEBUG
                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2619: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                } else {
                        if (((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SC) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD))) {
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2625: %s for machine %s.\n", "assert failure", name());

                            }
                            #endif
                            ;
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2626: %s for machine %s.\n", "assert failure", name());

                            }
                            #endif
                            ;
                            (*m_tbe_ptr).m_dir_ownerExists = (false);
                            (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                            (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD)) {
                                    (*m_tbe_ptr).m_dir_ownerExists = (true);
                                    (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                }
                            } else {
                                    if (((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I_Fwded_UC) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I_Fwded_UD_PD))) {
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2639: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2640: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                        (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                                        (*m_tbe_ptr).m_dir_ownerIsExcl = (true);
                                        (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                    } else {
                                            if ((((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_UC_Fwded_I) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_UD_Fwded_I)) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SD_Fwded_I))) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2652: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2653: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_I)) {
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:2657: %s for machine %s.\n", "assert failure", name());

                                                        }
                                                        #endif
                                                        ;
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:2658: %s for machine %s.\n", "assert failure", name());

                                                        }
                                                        #endif
                                                        ;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (*m_tbe_ptr).m_dir_ownerExists;
                                }
                                (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2668: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2672: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (*m_tbe_ptr).m_is_stale))) {
        panic("Runtime Error at CHI-cache-actions.sm:2674: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp_WUNeedComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_WUNeedComp\n");
    try {
       (*m_tbe_ptr).m_defer_expected_comp = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_WUNeedComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp_WUComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_WUComp\n");
    try {
           if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
    } else {
            if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_Comp)) == (false))) {
                panic("Runtime Error at CHI-cache-actions.sm:2686: %s for machine %s.\n", ("Received unexpected message"), name());
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_WUComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Copy the rsp DBID into the TBE */
void
Cache_Controller::Receive_ReqResp_CopyDBID(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_CopyDBID\n");
    try {
           if ((((((*m_tbe_ptr).m_expected_req_resp).receivedRespType(CHIResponseType_DBIDResp)) == (false)) && ((((*m_tbe_ptr).m_expected_req_resp).receivedRespType(CHIResponseType_CompDBIDResp)) == (false)))) {
        panic("Runtime Error at CHI-cache-actions.sm:2693: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }
    {
        // Declare message
        [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
        in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
        if (in_msg_ptr == NULL) {
            // If the cast fails, this is the wrong inport (wrong message type).
            // Throw an exception, and the caller will decide to either try a
            // different inport or punt.
            throw RejectException();
        }
    (*m_tbe_ptr).m_txnId = ((*in_msg_ptr)).m_dbid;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_CopyDBID: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_SnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpResp\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2701: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2705: %s for machine %s.\n", ("Received unexpected message"), name());
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (*m_tbe_ptr).m_is_stale))) {
        panic("Runtime Error at CHI-cache-actions.sm:2707: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_SnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RetryAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RetryAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2712: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2713: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_rcvdRetryAck == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2714: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_rcvdRetryAck = (true);
(((*m_destsWaitingRetry_ptr)).addNetDest((*m_tbe_ptr).m_pendReqDest));
(enqueueDoRetry(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RetryAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_PCrdGrant(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_PCrdGrant\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2721: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_rcvdRetryCredit == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2722: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_rcvdRetryCredit = (true);
(enqueueDoRetry(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_PCrdGrant: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2728: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2729: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2730: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry_DVM\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2737: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2738: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2739: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequestRetryDVM(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(((*m_destsWaitingRetry_ptr)).removeNetDest((*m_tbe_ptr).m_pendReqDest));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RetryAck_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RetryAck_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2748: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*hazard_tbe).m_rcvdRetryAck == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2749: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*hazard_tbe).m_rcvdRetryAck = (true);
(((*m_destsWaitingRetry_ptr)).addNetDest((*hazard_tbe).m_pendReqDest));
(enqueueDoRetry(hazard_tbe));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RetryAck_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_PCrdGrant_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_PCrdGrant_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2757: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*hazard_tbe).m_rcvdRetryCredit == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2758: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*hazard_tbe).m_rcvdRetryCredit = (true);
(enqueueDoRetry(hazard_tbe));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_PCrdGrant_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2765: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*hazard_tbe).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2766: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*hazard_tbe).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2767: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequestRetry(hazard_tbe, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2774: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2775: %s for machine %s.\n", "assert failure", name());

}
#endif
;
bool is_rd_once
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadOnce);
bool is_rd_no_snp
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNoSnp);
bool is_rd_shared
 = (((*m_tbe_ptr).m_reqType == CHIRequestType_ReadShared) || ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNotSharedDirty));
bool is_rd_nsd
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNotSharedDirty);
bool is_rd_unique
 = (((*m_tbe_ptr).m_reqType == CHIRequestType_ReadUnique) || ((*m_tbe_ptr).m_reqType == CHIRequestType_MakeReadUnique));
bool snd_unique_on_rs
 = ((((m_fwd_unique_on_readshared || (*m_tbe_ptr).m_dataToBeInvalid) || ((*m_tbe_ptr).m_dataDirty && is_rd_nsd)) && (*m_tbe_ptr).m_dataUnique) && (((*m_tbe_ptr).m_dir_sharers).isEmpty()));
bool snd_dirty_on_rs
 = ((is_rd_shared && (! is_rd_nsd)) && (! (*m_tbe_ptr).m_dir_ownerExists));
    if ((is_rd_once || is_rd_no_snp)) {
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
    } else {
            if ((is_rd_unique || (is_rd_shared && snd_unique_on_rs))) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataUnique)) {
                    panic("Runtime Error at CHI-cache-actions.sm:2801: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                    if ((*m_tbe_ptr).m_dataDirty) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
                    } else {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
                    }
                } else {
                        if (is_rd_shared) {
                                if (((*m_tbe_ptr).m_dataDirty && snd_dirty_on_rs)) {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SD_PD;
                                } else {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
                                }
                            } else {
                                panic("Runtime Error at CHI-cache-actions.sm:2816: %s for machine %s.\n", ("Invalid request type"), name());
                                ;
                            }
                        }
                    }
                    (*m_tbe_ptr).m_dataMaybeDirtyUpstream = ((((*m_tbe_ptr).m_dataMaybeDirtyUpstream || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_SD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UC));
                    (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (((*m_tbe_ptr).m_requestorToBeExclusiveOwner || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UC));
                    (*m_tbe_ptr).m_requestorToBeOwner = ((*m_tbe_ptr).m_requestorToBeOwner || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_SD_PD));
                    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                    (setupPendingSend(m_tbe_ptr));
                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WBData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WBData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2835: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (m_is_HN) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2837: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataDirty)) {
            panic("Runtime Error at CHI-cache-actions.sm:2838: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid || (((*m_tbe_ptr).m_dir_ownerIsExcl && (*m_tbe_ptr).m_dataUnique) && (*m_tbe_ptr).m_dataDirty)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2840: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
    } else {
            if (((*m_tbe_ptr).m_dataValid == (false))) {
                    if ((((*m_tbe_ptr).m_dir_ownerIsExcl && (*m_tbe_ptr).m_dataUnique) && (*m_tbe_ptr).m_dataDirty)) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UD_PD;
                    } else {
                        #ifndef NDEBUG
                        if (!((*m_tbe_ptr).m_is_stale)) {
                            panic("Runtime Error at CHI-cache-actions.sm:2849: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        (((*m_tbe_ptr).m_dataBlkValid).fillMask());
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_I;
                    }
                } else {
                        if ((*m_tbe_ptr).m_dataUnique) {
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2854: %s for machine %s.\n", "assert failure", name());

                            }
                            #endif
                            ;
                                if ((*m_tbe_ptr).m_dataDirty) {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UD_PD;
                                } else {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UC;
                                }
                            } else {
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:2861: %s for machine %s.\n", "assert failure", name());

                                }
                                #endif
                                ;
                                    if ((*m_tbe_ptr).m_dataDirty) {
                                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_SD_PD;
                                    } else {
                                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_SC;
                                    }
                                }
                            }
                        }
                        (*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
                        (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WBData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WUData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WUData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2874: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dataBlkValid).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2875: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
(*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
(setupPendingPartialSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WUData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckWUComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckWUComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2882: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckWUComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ARData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ARData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2891: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
(*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
(setupPendingAtomicSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ARData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ANRData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ANRData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2898: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
(*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
(setupPendingAtomicSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ANRData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckARComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckARComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2905: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_I));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckARComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckANRComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckANRComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2913: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
        (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckANRComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespData\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2922: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2923: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2924: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2925: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_snpNeedsData || ((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpCleanInvalid))) || (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpShared))) || (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique))))) {
    panic("Runtime Error at CHI-cache-actions.sm:2930: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_dataToBeInvalid && (((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2933: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
            if ((*m_tbe_ptr).m_dataDirty) {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_PD;
            } else {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I;
            }
        } else {
                if ((*m_tbe_ptr).m_dataToBeSharedClean) {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2940: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                        if ((*m_tbe_ptr).m_dataDirty) {
                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_PD;
                        } else {
                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC;
                        }
                    } else {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnce))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2947: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_dataDirty && (*m_tbe_ptr).m_dataUnique)) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_UD;
                            } else {
                                    if ((*m_tbe_ptr).m_dataDirty) {
                                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SD;
                                    } else {
                                            if ((*m_tbe_ptr).m_dataUnique) {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_UC;
                                            } else {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC;
                                            }
                                        }
                                    }
                                }
                            }
                            (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                            (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpUniqueFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpUniqueFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2964: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeInvalid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2965: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2966: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*m_tbe_ptr).m_dataDirty) {
        (*m_tbe_ptr).m_fwdedState = Cache_State_UD;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
    } else {
        (*m_tbe_ptr).m_fwdedState = Cache_State_UC;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpUniqueFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpSharedFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpSharedFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2982: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2983: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2984: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*m_tbe_ptr).m_dataDirty) {
        (*m_tbe_ptr).m_fwdedState = Cache_State_SD;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SD_PD;
    } else {
        (*m_tbe_ptr).m_fwdedState = Cache_State_SC;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
    }
        if ((*m_tbe_ptr).m_snpNeedsData) {
            (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedData));
        } else {
            (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
        }
        (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
        (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpSharedFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpNSDFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpNSDFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3004: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:3005: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3006: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
(*m_tbe_ptr).m_fwdedState = Cache_State_SC;
    if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_snpNeedsData)) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedData));
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
    }
    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpNSDFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpOnceFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpOnceFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3021: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_fwdedState = Cache_State_I;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
(((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
(*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
(setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpOnceFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespDataFwded(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespDataFwded\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3032: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:3035: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3036: %s for machine %s.\n", "assert failure", name());

}
#endif
;
bool keepData
 = (((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) || ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
    if (keepData) {
            if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_Fwded_SD_PD;
            } else {
                    if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_PD_Fwded_SC;
                    } else {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_Fwded_SC;
                    }
                }
            } else {
                    if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_Fwded_SD_PD;
                    } else {
                            if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_PD_Fwded_SC;
                            } else {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_Fwded_SC;
                            }
                        }
                    }
                    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespDataFwded: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_FwdSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_FwdSnpResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3065: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3066: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    bool keepData
     = (((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) || ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
        if ((keepData && (*m_tbe_ptr).m_dataToBeSharedClean)) {
            #ifndef NDEBUG
            if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_SnpSharedFwd) || ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpNotSharedDirtyFwd)))) {
                panic("Runtime Error at CHI-cache-actions.sm:3079: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                panic("Runtime Error at CHI-cache-actions.sm:3080: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
                if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                    (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_SD_PD;
                } else {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                        panic("Runtime Error at CHI-cache-actions.sm:3084: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                    (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_SC;
                }
            } else {
                    if (keepData) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnceFwd))) {
                            panic("Runtime Error at CHI-cache-actions.sm:3089: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_I))) {
                            panic("Runtime Error at CHI-cache-actions.sm:3090: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_dataUnique && ((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream))) {
                                (*out_msg).m_type = CHIResponseType_SnpResp_UD_Fwded_I;
                            } else {
                                    if ((*m_tbe_ptr).m_dataUnique) {
                                        (*out_msg).m_type = CHIResponseType_SnpResp_UC_Fwded_I;
                                    } else {
                                            if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                                                (*out_msg).m_type = CHIResponseType_SnpResp_SD_Fwded_I;
                                            } else {
                                                (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_I;
                                            }
                                        }
                                    }
                                } else {
                                    #ifndef NDEBUG
                                    if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:3102: %s for machine %s.\n", "assert failure", name());

                                    }
                                    #endif
                                    ;
                                    #ifndef NDEBUG
                                    if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:3103: %s for machine %s.\n", "assert failure", name());

                                    }
                                    #endif
                                    ;
                                        if (((*m_tbe_ptr).m_fwdedState == Cache_State_UD)) {
                                            (*out_msg).m_type = CHIResponseType_SnpResp_I_Fwded_UD_PD;
                                        } else {
                                            #ifndef NDEBUG
                                            if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_UC))) {
                                                panic("Runtime Error at CHI-cache-actions.sm:3107: %s for machine %s.\n", "assert failure", name());

                                            }
                                            #endif
                                            ;
                                            (*out_msg).m_type = CHIResponseType_SnpResp_I_Fwded_UC;
                                        }
                                    }
                                }
                                ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
                            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_FwdSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Data(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Data\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_snd_pendEv)) {
    panic("Runtime Error at CHI-cache-actions.sm:3115: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_snd_pendBytes).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3116: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_snd_pendEv = (false);
{
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = (*m_tbe_ptr).m_snd_msgType;
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    int offset
     = (((*m_tbe_ptr).m_snd_pendBytes).firstBitSet((true)));
    #ifndef NDEBUG
    if (!((offset < (*m_blockSize_ptr)))) {
        panic("Runtime Error at CHI-cache-actions.sm:3124: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    int range
     = ((((*m_tbe_ptr).m_snd_pendBytes).firstBitSet((false), offset)) - offset);
    #ifndef NDEBUG
    if (!(((range > (0)) && (range <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:3126: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
        if ((range > m_data_channel_size)) {
            range = m_data_channel_size;
        }
        (((*m_tbe_ptr).m_snd_pendBytes).setMask(offset, range, (false)));
            if ((((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicReturn) && ((*m_tbe_ptr).m_atomic_to_be_wb == (false)))) {
                (*out_msg).m_dataBlk = (*m_tbe_ptr).m_oldDataBlk;
            } else {
                (*out_msg).m_dataBlk = (*m_tbe_ptr).m_dataBlk;
            }
            (((*out_msg).m_bitMask).setMask(offset, range));
            (*out_msg).m_responder = m_machineID;
            (((*out_msg).m_Destination).add((*m_tbe_ptr).m_snd_destination));
            ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
        (scheduleSendData(m_tbe_ptr, (1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Data: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_RespSepData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RespSepData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3151: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_RespSepData;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_RespSepData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompI(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompI\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3161: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((! (isStashReqType((*m_tbe_ptr).m_reqType)))) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3165: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != (*m_tbe_ptr).m_requestor)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3166: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).remove((*m_tbe_ptr).m_requestor));
    }
    {
        std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
        (*out_msg).m_addr = addr;
        (*out_msg).m_type = CHIResponseType_Comp_I;
        (*out_msg).m_responder = m_machineID;
        (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
        (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
        (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
        ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompI: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompUC(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompUC\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3182: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_UC;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompUC: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompUC_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompUC_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3194: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_UC;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompUC_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompUD_PD(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompUD_PD\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3209: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_UD_PD;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompUD_PD: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3221: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompI_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompI_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3232: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_I;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompI_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompDBIDResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompDBIDResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3247: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompDBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompDBIDResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompDBIDResp_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompDBIDResp_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3259: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompDBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompDBIDResp_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DBIDResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DBIDResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3274: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_DBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_dbid = (*m_tbe_ptr).m_txnId;
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DBIDResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Comp_WU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Comp_WU\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3285: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((m_comp_wu_latency + m_response_latency))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Comp_WU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_AR(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_AR\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3296: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3297: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
(*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
(*m_tbe_ptr).m_requestorToBeExclusiveOwner = (false);
(*m_tbe_ptr).m_requestorToBeOwner = (false);
(*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
(setupPendingSend(m_tbe_ptr));
(printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_AR: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Comp_ANR(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Comp_ANR\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3310: %s for machine %s.\n", "assert failure", name());

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((m_comp_anr_latency + m_response_latency))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Comp_ANR: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespI(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespI\n");
    try {
       {
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = addr;
        if (((*m_tbe_ptr).m_is_dvm_tbe || (*m_tbe_ptr).m_is_dvm_snp_tbe)) {
            (*out_msg).m_usesTxnId = (true);
            (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
        }
        (*out_msg).m_type = CHIResponseType_SnpResp_I;
        (*out_msg).m_responder = m_machineID;
        (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
        ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespI: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_RetryAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RetryAck\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const Cache_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
    (*out_msg).m_usesTxnId = ((*in_msg_ptr)).m_usesTxnId;
    (*out_msg).m_type = CHIResponseType_RetryAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    (*out_msg).m_txnId = ((*in_msg_ptr)).m_txnId;
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_RetryAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_PCrdGrant(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_PCrdGrant\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const Cache_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
    (*out_msg).m_usesTxnId = ((*in_msg_ptr)).m_usesTxnId;
    (*out_msg).m_type = CHIResponseType_PCrdGrant;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_PCrdGrant: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromStoreOrRU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromStoreOrRU\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3366: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*m_tbe_ptr).m_dataUnique) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:3369: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendReadUnique));
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_is_stale)) {
            panic("Runtime Error at CHI-cache-actions.sm:3375: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_stale = (false);
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromStoreOrRU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromCU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromCU\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3382: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_dataUnique == (false))) {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3385: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (false);
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromCU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_UpdateCacheFromTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_UpdateCacheFromTBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3395: %s for machine %s.\n", "assert failure", name());

}
#endif
;
Cache_State final
 = (*m_tbe_ptr).m_finalState;
    if ((((((((((((((final == Cache_State_UD_RSC) || (final == Cache_State_SD_RSC)) || (final == Cache_State_UC_RSC)) || (final == Cache_State_SC_RSC)) || (final == Cache_State_UD)) || (final == Cache_State_UD_T)) || (final == Cache_State_SD)) || (final == Cache_State_UC)) || (final == Cache_State_SC)) || (final == Cache_State_UC_RU)) || (final == Cache_State_UD_RU)) || (final == Cache_State_UD_RSD)) || (final == Cache_State_SD_RSD))) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:3402: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:3403: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:3404: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*m_cache_entry_ptr).m_DataBlk = (*m_tbe_ptr).m_dataBlk;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3406: Cached data %s pfb %s\n", (*m_tbe_ptr).m_dataBlk, (*m_cache_entry_ptr).m_HWPrefetched);
    } else {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3409: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
            if ((m_cache_entry_ptr != NULL)) {
                (((*m_cache_ptr)).deallocate(addr));
                unset_cache_entry(m_cache_entry_ptr);;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_UpdateCacheFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_UpdateDirectoryFromTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_UpdateDirectoryFromTBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3418: %s for machine %s.\n", "assert failure", name());

}
#endif
;
Cache_State final
 = (*m_tbe_ptr).m_finalState;
    if ((((((((((((((final == Cache_State_UD_RSC) || (final == Cache_State_SD_RSC)) || (final == Cache_State_UC_RSC)) || (final == Cache_State_SC_RSC)) || (final == Cache_State_UC_RU)) || (final == Cache_State_UD_RU)) || (final == Cache_State_UD_RSD)) || (final == Cache_State_SD_RSD)) || (final == Cache_State_RU)) || (final == Cache_State_RSC)) || (final == Cache_State_RSD)) || (final == Cache_State_RUSD)) || (final == Cache_State_RUSC))) {
        Cache_DirEntry* dir_entry
         = (getDirEntry(addr));
        #ifndef NDEBUG
        if (!((dir_entry != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:3426: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3427: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*dir_entry).m_ownerExists = (*m_tbe_ptr).m_dir_ownerExists;
        (*dir_entry).m_ownerIsExcl = (*m_tbe_ptr).m_dir_ownerIsExcl;
        (*dir_entry).m_owner = (*m_tbe_ptr).m_dir_owner;
        (*dir_entry).m_sharers = (*m_tbe_ptr).m_dir_sharers;
    } else {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) && (((*m_tbe_ptr).m_dir_sharers).isEmpty())))) {
            panic("Runtime Error at CHI-cache-actions.sm:3433: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
            if ((((*m_directory_ptr)).isTagPresent(addr))) {
                (((*m_directory_ptr)).deallocate(addr));
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_UpdateDirectoryFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Deallocate_CacheBlock(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Deallocate_CacheBlock\n");
    try {
       #ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3441: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_cache_ptr)).deallocate(addr));
unset_cache_entry(m_cache_entry_ptr);;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Deallocate_CacheBlock: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Allocate_DirEntry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Allocate_DirEntry\n");
    try {
       #ifndef NDEBUG
if (!(((((*m_directory_ptr)).isTagPresent(addr)) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3447: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_directory_ptr)).allocate(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Allocate_DirEntry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Deallocate_DirEntry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Deallocate_DirEntry\n");
    try {
       #ifndef NDEBUG
if (!((((*m_directory_ptr)).isTagPresent(addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3452: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_directory_ptr)).deallocate(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Deallocate_DirEntry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckCacheFill(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckCacheFill\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3457: %s for machine %s.\n", "assert failure", name());

}
#endif
;
bool need_fill
 = (((*m_tbe_ptr).m_dataValid && ((*m_tbe_ptr).m_dataToBeInvalid == (false))) && (*m_tbe_ptr).m_doCacheFill);
bool execute_next
 = (true);
    if ((need_fill && (m_cache_entry_ptr != NULL))) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_DataArrayWrite));
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_FillPipe));
    } else {
            if ((need_fill && (((*m_cache_ptr)).cacheAvail(addr)))) {
                set_cache_entry(m_cache_entry_ptr, (((*m_cache_ptr)).allocate(addr, new Cache_CacheEntry)));;
                (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_DataArrayWriteOnFill));
                (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_FillPipe));
            } else {
                    if (need_fill) {
                        execute_next = (false);
                        Addr victim_addr
                         = (((*m_cache_ptr)).cacheProbe(addr));
                        Cache_CacheEntry* victim_entry
                         = (getCacheEntry(victim_addr));
                        #ifndef NDEBUG
                        if (!((victim_entry != NULL))) {
                            panic("Runtime Error at CHI-cache-actions.sm:3482: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        Cache_TBE* victim_tbe
                         = (getCurrentActiveTBE(victim_addr));
                            if (((victim_tbe == NULL) && (victim_entry != NULL))) {
                                DPRINTF(RubySlicc, "CHI-cache-actions.sm:3488: Eviction for %#x victim: %#x state=%s\n", addr, victim_addr, (*victim_entry).m_state);
                                {
                                    std::shared_ptr<Cache_ReplacementMsg> out_msg = std::make_shared<Cache_ReplacementMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
                                    (*out_msg).m_addr = victim_addr;
                                    (*out_msg).m_from_addr = addr;
                                        if (m_unify_repl_TBEs) {
                                            (*out_msg).m_slot = (*m_tbe_ptr).m_storSlot;
                                            DPRINTF(RubySlicc, "CHI-cache-actions.sm:3495: Reusing slot %d\n", (*out_msg).m_slot);
                                        }
                                        ((*m_replTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
                                    }
                                } else {
                                    DPRINTF(RubySlicc, "CHI-cache-actions.sm:3499: Eviction for %#x victim: %#x state=%s\n", addr, victim_addr, (*victim_tbe).m_state);
                                    (*victim_tbe).m_wakeup_pending_tgr = (true);
                                }
                                        stallBuffer(&((*m_triggerQueue_ptr)), victim_addr);
                                        (*m_triggerQueue_ptr).stallMessage(victim_addr, clockEdge());
                                        
                            }
                        }
                    }
                        if (execute_next) {
                            (((*m_triggerQueue_ptr)).dequeue((clockEdge())));
                            (clearPendingAction(m_tbe_ptr));
                            (processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));
                        } else {
                            (wakeupPendingSnps(m_tbe_ptr));
                        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckCacheFill: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3521: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:3522: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
    if ((*m_tbe_ptr).m_is_req_tbe) {
        (deallocateReqTBE(m_tbe_ptr));
        (processRetryQueue());
    } else {
            if ((*m_tbe_ptr).m_is_snp_tbe) {
                (deallocateSnpTBE(m_tbe_ptr));
            } else {
                (deallocateReplacementTBE(m_tbe_ptr));
                    if (m_unify_repl_TBEs) {
                        (processRetryQueue());
                    }
                }
            }
            unset_tbe(m_tbe_ptr);;
            (incomingTransactionEnd(addr, (curTransitionNextState())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateDvmRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateDvmRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3546: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:3547: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:3554: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(deallocateDvmTBE(m_tbe_ptr));
unset_tbe(m_tbe_ptr);;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateDvmRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateDvmSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateDvmSnoop\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3560: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:3561: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:3568: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(deallocateDvmSnoopTBE(m_tbe_ptr));
unset_tbe(m_tbe_ptr);;
(incomingTransactionEnd(addr, (curTransitionNextState()), (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateDvmSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_ReqRdyQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReqRdyQueue\n");
    try {
       (((*m_reqRdy_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_ReqRdyQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_RespInQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RespInQueue\n");
    try {
       (((*m_rspIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_RespInQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SnoopRdyQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SnoopRdyQueue\n");
    try {
       (((*m_snpRdy_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SnoopRdyQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_DataInQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_DataInQueue\n");
    try {
       (((*m_datIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_DataInQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_TriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_TriggerQueue\n");
    try {
       (((*m_triggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_TriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_ReplTriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReplTriggerQueue\n");
    try {
       (((*m_replTriggerQueue_ptr)).dequeue((clockEdge())));
        wakeUpBuffer(&((*m_triggerQueue_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_ReplTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_RetryTriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RetryTriggerQueue\n");
    try {
       (((*m_retryTriggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_RetryTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SnpInPort(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SnpInPort\n");
    try {
       (((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SnpInPort: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SeqInPort(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SeqInPort\n");
    try {
       (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SeqInPort: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ProcessNextState(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3617: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ProcessNextState: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ProcessNextState_ClearPending(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState_ClearPending\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3622: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearPendingAction(m_tbe_ptr));
(processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ProcessNextState_ClearPending: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_LoadHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_LoadHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3628: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_Load))) {
    panic("Runtime Error at CHI-cache-actions.sm:3629: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:3631: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3632: Read data %s\n", (*m_tbe_ptr).m_dataBlk);
        (((*m_sequencer_ptr)).readCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (false)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_LoadHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_StoreHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_StoreHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3638: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3640: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:3642: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3643: Write before %s\n", (*m_tbe_ptr).m_dataBlk);
        (((*m_sequencer_ptr)).writeCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (false)));
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3645: Write after %s\n", (*m_tbe_ptr).m_dataBlk);
        (*m_tbe_ptr).m_dataDirty = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_StoreHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_AtomicHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_AtomicHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3651: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3652: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicLoad) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicStore)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3654: %s for machine %s.\n", "assert failure", name());

}
#endif
;
DPRINTF(RubySlicc, "CHI-cache-actions.sm:3655: Atomic before %s\n", (*m_tbe_ptr).m_dataBlk);
DataBlock oldDataBlk;
oldDataBlk = (*m_tbe_ptr).m_dataBlk;
(((*m_tbe_ptr).m_dataBlk).atomicPartial((*m_tbe_ptr).m_dataBlk, (*m_tbe_ptr).m_atomic_op));
(((*m_tbe_ptr).m_dataBlk).clearAtomicLogEntries());
(((*m_sequencer_ptr)).atomicCallback((*m_tbe_ptr).m_addr, oldDataBlk, (false)));
DPRINTF(RubySlicc, "CHI-cache-actions.sm:3663: Atomic after %s\n", (*m_tbe_ptr).m_dataBlk);
(*m_tbe_ptr).m_dataDirty = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_AtomicHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_ExpressPrefetchHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_ExpressPrefetchHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr == NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3669: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_storTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-actions.sm:3671: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(m_use_prefetcher)) {
    panic("Runtime Error at CHI-cache-actions.sm:3672: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_cache_ptr)).profilePrefetchHit());
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!(((*in_msg_ptr)).m_is_local_pf)) {
    panic("Runtime Error at CHI-cache-actions.sm:3676: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_pfProxy_ptr)).completePrefetch(((*in_msg_ptr)).m_addr));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_ExpressPrefetchHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_Miss\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3685: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_is_local_pf)) {
        #ifndef NDEBUG
        if (!(m_use_prefetcher)) {
            panic("Runtime Error at CHI-cache-actions.sm:3687: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_pfProxy_ptr)).completePrefetch((*m_tbe_ptr).m_addr));
    } else {
            if (((*m_tbe_ptr).m_dataValid && ((*m_tbe_ptr).m_reqType == CHIRequestType_Load))) {
                DPRINTF(RubySlicc, "CHI-cache-actions.sm:3691: Read data %s\n", (*m_tbe_ptr).m_dataBlk);
                (((*m_sequencer_ptr)).readCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (true)));
            } else {
                    if (((*m_tbe_ptr).m_dataValid && (((*m_tbe_ptr).m_reqType == CHIRequestType_Store) || ((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine)))) {
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3696: Write before %s\n", (*m_tbe_ptr).m_dataBlk);
                        (((*m_sequencer_ptr)).writeCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (true)));
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3698: Write after %s\n", (*m_tbe_ptr).m_dataBlk);
                        (*m_tbe_ptr).m_dataDirty = (true);
                        int use_timeout_latency
                         = (scLockLatency());
                            if ((use_timeout_latency > (0))) {
                                    if ((*m_tbe_ptr).m_hasUseTimeout) {
                                        #ifndef NDEBUG
                                        if (!((((*m_useTimerTable_ptr)).isSet((*m_tbe_ptr).m_addr)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:3705: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                    } else {
                                        (((*m_useTimerTable_ptr)).set((*m_tbe_ptr).m_addr, ((clockEdge()) + (cyclesToTicks((intToCycles(use_timeout_latency)))))));
                                        (*m_tbe_ptr).m_hasUseTimeout = (true);
                                    }
                                    (scLockDecayLatency());
                                }
                            } else {
                                    if ((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_atomic_to_be_done) && (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicLoad) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicStore)))) {
                                        #ifndef NDEBUG
                                        if (!((m_tbe_ptr != NULL))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:3718: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!((*m_tbe_ptr).m_dataValid)) {
                                            panic("Runtime Error at CHI-cache-actions.sm:3719: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicLoad) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicStore)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:3721: %s for machine %s.\n", "assert failure", name());

                                        }
                                        #endif
                                        ;
                                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3722: Atomic before %s\n", (*m_tbe_ptr).m_dataBlk);
                                        DataBlock oldDataBlk;
                                        oldDataBlk = (*m_tbe_ptr).m_dataBlk;
                                        (((*m_tbe_ptr).m_dataBlk).atomicPartial((*m_tbe_ptr).m_dataBlk, (*m_tbe_ptr).m_atomic_op));
                                        (((*m_tbe_ptr).m_dataBlk).clearAtomicLogEntries());
                                        (((*m_sequencer_ptr)).atomicCallback((*m_tbe_ptr).m_addr, oldDataBlk, (false)));
                                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3730: Atomic after %s\n", (*m_tbe_ptr).m_dataBlk);
                                        (*m_tbe_ptr).m_dataDirty = (true);
                                    } else {
                                            if ((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataAMOValid) && ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicLoad))) {
                                                DPRINTF(RubySlicc, "CHI-cache-actions.sm:3733: Atomic before %s\n", (*m_tbe_ptr).m_oldDataBlk);
                                                (((*m_sequencer_ptr)).atomicCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_oldDataBlk, (false)));
                                            }
                                        }
                                    }
                                }
                            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Unset_Timeout_TBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Unset_Timeout_TBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3739: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_hasUseTimeout)) {
    panic("Runtime Error at CHI-cache-actions.sm:3740: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_useTimerTable_ptr)).isSet((*m_tbe_ptr).m_addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3741: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_useTimerTable_ptr)).unset((*m_tbe_ptr).m_addr));
(*m_tbe_ptr).m_hasUseTimeout = (false);
        wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Unset_Timeout_TBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Unset_Timeout_Cache(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Unset_Timeout_Cache\n");
    try {
       #ifndef NDEBUG
if (!((((*m_useTimerTable_ptr)).isSet(addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3749: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_useTimerTable_ptr)).unset(addr));
        wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Unset_Timeout_Cache: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_AtomicNoReturn(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_AtomicNoReturn\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3755: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3756: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicNoReturn) || ((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicStore)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3758: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (((*m_tbe_ptr).m_reqType == CHIRequestType_AtomicStore)) {
        (((*m_sequencer_ptr)).atomicCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk));
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3762: AtomicNoReturn %s\n", (*m_tbe_ptr).m_dataBlk);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_AtomicNoReturn: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_WriteUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_WriteUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3767: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3768: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3770: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3771: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_sequencer_ptr)).writeUniqueCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk));
DPRINTF(RubySlicc, "CHI-cache-actions.sm:3773: WriteUnique data %s\n", (*m_tbe_ptr).m_dataBlk);
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:3775: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_tbe_ptr).m_dataBlkValid).setMask((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)), (*m_tbe_ptr).m_accSize));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_WriteUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Miss\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3780: %s for machine %s.\n", "assert failure", name());

}
#endif
;
bool is_demand
 = (((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false));
bool is_remote_can_notify
 = ((*m_tbe_ptr).m_is_remote_pf && m_upstream_prefetch_trains_prefetcher);
    if (is_demand) {
        (((*m_cache_ptr)).profileDemandMiss());
    } else {
        #ifndef NDEBUG
        if (!((m_use_prefetcher || (*m_tbe_ptr).m_is_remote_pf))) {
            panic("Runtime Error at CHI-cache-actions.sm:3786: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_cache_ptr)).profilePrefetchMiss());
    }
        if (((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid) && (is_demand || is_remote_can_notify))) {
            bool is_read
             = (false);
                if ((isReadReqType((*m_tbe_ptr).m_reqType))) {
                    is_read = (true);
                } else {
                    #ifndef NDEBUG
                    if (!((isWriteReqType((*m_tbe_ptr).m_reqType)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:3795: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                }
                (((*m_pfProxy_ptr)).notifyPfMiss((*m_tbe_ptr).m_seqReq, is_read, (*m_tbe_ptr).m_dataBlk));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Hit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3805: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3806: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3807: %s for machine %s.\n", "assert failure", name());

}
#endif
;
bool is_demand
 = (((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false));
bool is_remote_can_notify
 = ((*m_tbe_ptr).m_is_remote_pf && m_upstream_prefetch_trains_prefetcher);
    if (is_demand) {
        (((*m_cache_ptr)).profileDemandHit());
    } else {
        #ifndef NDEBUG
        if (!((m_use_prefetcher || (*m_tbe_ptr).m_is_remote_pf))) {
            panic("Runtime Error at CHI-cache-actions.sm:3813: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*m_cache_ptr)).profilePrefetchHit());
    }
        if (((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid) && (is_demand || is_remote_can_notify))) {
            bool is_read
             = (false);
                if ((isReadReqType((*m_tbe_ptr).m_reqType))) {
                    is_read = (true);
                } else {
                    #ifndef NDEBUG
                    if (!((isWriteReqType((*m_tbe_ptr).m_reqType)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:3822: %s for machine %s.\n", "assert failure", name());

                    }
                    #endif
                    ;
                }
                (((*m_pfProxy_ptr)).notifyPfHit((*m_tbe_ptr).m_seqReq, is_read, (*m_tbe_ptr).m_dataBlk));
                (*m_cache_entry_ptr).m_HWPrefetched = (false);
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Fill(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Fill\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3831: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3832: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid)) {
        (*m_cache_entry_ptr).m_HWPrefetched = ((*m_tbe_ptr).m_is_local_pf || ((*m_tbe_ptr).m_is_remote_pf && (m_upstream_prefetch_trains_prefetcher == (false))));
        (*m_cache_entry_ptr).m_requestor = (getRequestorID((*m_tbe_ptr).m_seqReq));
        (((*m_pfProxy_ptr)).notifyPfFill((*m_tbe_ptr).m_seqReq, (*m_tbe_ptr).m_dataBlk, (*m_tbe_ptr).m_is_local_pf));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Fill: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Eviction(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Eviction\n");
    try {
           if ((m_sc_lock_enabled && (((*m_sequencer_ptr)).llscCheckMonitor(addr)))) {
        DPRINTF(LLSC, "CHI-cache-actions.sm:3848: Invalidating monitored address %#x\n", addr);
        (scLockIncLatency());
    }
        if (m_send_evictions) {
            DPRINTF(RubySlicc, "CHI-cache-actions.sm:3852: Sending invalidation for %#x to the sequencer\n", addr);
            (((*m_sequencer_ptr)).evictionCallback(addr));
        }
            if ((m_use_prefetcher && (m_cache_entry_ptr != NULL))) {
                (((*m_pfProxy_ptr)).notifyPfEvict(addr, (*m_cache_entry_ptr).m_HWPrefetched, (*m_cache_entry_ptr).m_requestor));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Eviction: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingStart(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingStart\n");
    try {
       (outgoingTransactionStart(addr, (curTransitionEvent())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingStart: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3865: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        (outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DatalessResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DatalessResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3873: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DatalessResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::TagArrayRead(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing TagArrayRead\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3878: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((tagLatency((fromSequencer((*m_tbe_ptr).m_reqType)))))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:TagArrayRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::TagArrayWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing TagArrayWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3884: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((m_dealloc_wait_for_tag && ((*m_tbe_ptr).m_hasUseTimeout == (false)))) {
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((tagLatency((false))))));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:TagArrayWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DataArrayRead(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DataArrayRead\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3894: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((dataLatency()))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DataArrayRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DataArrayWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DataArrayWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3899: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3900: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_doCacheFill)) {
    panic("Runtime Error at CHI-cache-actions.sm:3901: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (m_wait_for_cache_wr) {
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((dataLatency()))));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DataArrayWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ReadHitPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ReadHitPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3908: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_read_hit_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ReadHitPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ReadMissPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ReadMissPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3913: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_read_miss_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ReadMissPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteFEPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteFEPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3918: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_write_fe_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteFEPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteBEPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteBEPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3923: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_write_be_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteBEPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::FillPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing FillPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3928: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_fill_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:FillPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DelayAtomic(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DelayAtomic\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3933: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_atomic_op_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DelayAtomic: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpSharedPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpSharedPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3938: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_snp_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpSharedPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpInvPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpInvPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3943: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((m_snp_latency + m_snp_inv_latency))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpInvPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpOncePipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpOncePipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3948: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_snp_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpOncePipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmTlbi(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmTlbi\n");
    try {
       {
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_DvmOpNonSync, *out_msg));
    DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3958: Sending DvmOpNonSync to %d\n", (getMiscNodeMachine()));
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3988: Pushing pending nonsync to blocklist %16x\n", (*m_tbe_ptr).m_addr);
(((*m_dvmPendingNonSyncsBlockingSync_ptr)).push(Cache_Event_DvmTlbi_Initiate));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmTlbi: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Try_Send_DvmSync(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Try_Send_DvmSync\n");
    try {
           if ((((*m_dvmPendingNonSyncsBlockingSync_ptr)).empty())) {
        DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3996: Nonsync queue is empty so %016x can proceed\n", (*m_tbe_ptr).m_addr);
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DvmSync_Send));
    } else {
        #ifndef NDEBUG
        if (!((! (*m_dvmHasPendingSyncOp_ptr)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3999: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        DPRINTF(RubyProtocol, "CHI-cache-actions.sm:4000: Nonsync queue is not empty so %016x is now pending\n", (*m_tbe_ptr).m_addr);
        (*m_dvmHasPendingSyncOp_ptr) = (true);
        (*m_dvmPendingSyncOp_ptr) = addr;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Try_Send_DvmSync: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Try_Send_Pending_DvmSync(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Try_Send_Pending_DvmSync\n");
    try {
       #ifndef NDEBUG
if (!((! (((*m_dvmPendingNonSyncsBlockingSync_ptr)).empty())))) {
    panic("Runtime Error at CHI-cache-actions.sm:4012: %s for machine %s.\n", "assert failure", name());

}
#endif
;
DPRINTF(RubyProtocol, "CHI-cache-actions.sm:4013: Popping nonsync from blocklist %16x\n", (*m_tbe_ptr).m_addr);
(((*m_dvmPendingNonSyncsBlockingSync_ptr)).pop());
    if (((((*m_dvmPendingNonSyncsBlockingSync_ptr)).empty()) && (*m_dvmHasPendingSyncOp_ptr))) {
        DPRINTF(RubyProtocol, "CHI-cache-actions.sm:4017: Blocklist now empty, pending op %16x can proceed\n", (*m_dvmPendingSyncOp_ptr));
        Cache_TBE* syncTBE
         = (getDvmTBE((*m_dvmPendingSyncOp_ptr)));
        #ifndef NDEBUG
        if (!((syncTBE != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:4019: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (((*syncTBE).m_actions).push(Cache_Event_DvmSync_Send));
        (*m_dvmHasPendingSyncOp_ptr) = (false);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Try_Send_Pending_DvmSync: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmSync(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSync\n");
    try {
       {
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (prepareRequest(m_tbe_ptr, CHIRequestType_DvmOpSync, *out_msg));
    DPRINTF(RubyProtocol, "CHI-cache-actions.sm:4029: Sending DvmOpSync to %d\n", (getMiscNodeMachine()));
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmSync: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmTlbi_NCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmTlbi_NCBWrData\n");
    try {
       {
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = CHIDataType_NCBWrData;
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_dataBlk).clear());
    (((*out_msg).m_bitMask).setMask((0), (8)));
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmTlbi_NCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmSync_NCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSync_NCBWrData\n");
    try {
       {
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = CHIDataType_NCBWrData;
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_dataBlk).clear());
    (((*out_msg).m_bitMask).setMask((0), (8)));
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmSync_NCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmTlbi_CompCallback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmTlbi_CompCallback\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:4091: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:4092: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_DvmTlbi_Initiate))) {
    panic("Runtime Error at CHI-cache-actions.sm:4093: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_sequencer_ptr)).unaddressedCallback((*m_tbe_ptr).m_addr, RubyRequestType_TLBI));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmTlbi_CompCallback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmSync_CompCallback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmSync_CompCallback\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:4098: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:4099: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_DvmSync_Initiate))) {
    panic("Runtime Error at CHI-cache-actions.sm:4100: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_sequencer_ptr)).unaddressedCallback((*m_tbe_ptr).m_addr, RubyRequestType_TLBI_SYNC));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmSync_CompCallback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_DvmSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_DvmSnoop\n");
    try {
       bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateDvmSnoopTBE(addr, (*in_msg_ptr))));;
}
(incomingTransactionStart(addr, (curTransitionEvent()), Cache_State_I, was_retried, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_DvmSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmExtTlbi_EnqueueSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmExtTlbi_EnqueueSnpResp\n");
    try {
       (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_dvm_ext_tlbi_latency)));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpIResp));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmExtTlbi_EnqueueSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmExtSync_TriggerCallback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmExtSync_TriggerCallback\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:4125: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:4126: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_sequencer_ptr)).unaddressedCallback((*m_tbe_ptr).m_addr, RubyRequestType_TLBI_EXT_SYNC));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmExtSync_TriggerCallback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingStart_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingStart_DVM\n");
    try {
       (outgoingTransactionStart(addr, (curTransitionEvent()), (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingStart_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DVM\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:4135: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

Cache_CacheEntry*
Cache_Controller::getCacheEntry(const Addr& param_addr)
{
return static_cast<Cache_CacheEntry *>((((*m_cache_ptr)).lookup(param_addr)));

}
Cache_CacheEntry*
Cache_Controller::nullCacheEntry()
{
return NULL;

}
Cache_DirEntry*
Cache_Controller::getDirEntry(const Addr& param_addr)
{
    if ((((*m_directory_ptr)).isTagPresent(param_addr))) {
        return (((*m_directory_ptr)).lookup(param_addr));
    } else {
        return NULL;
    }

}
Cache_State
Cache_Controller::getState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, const Addr& param_addr)
{
    if ((param_tbe != NULL)) {
        return (*param_tbe).m_state;
    } else {
            if ((param_cache_entry != NULL)) {
                return (*param_cache_entry).m_state;
            } else {
                Cache_DirEntry* dir_entry
                 = (getDirEntry(param_addr));
                    if ((dir_entry != NULL)) {
                        return (*dir_entry).m_state;
                    } else {
                        return Cache_State_I;
                    }
                }
            }

}
void
Cache_Controller::setState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, const Addr& param_addr, const Cache_State& param_state)
{
    if ((param_tbe != NULL)) {
        (*param_tbe).m_state = param_state;
    }
        if ((param_cache_entry != NULL)) {
            (*param_cache_entry).m_state = param_state;
        }
        Cache_DirEntry* dir_entry
         = (getDirEntry(param_addr));
            if ((dir_entry != NULL)) {
                (*dir_entry).m_state = param_state;
            }

}
Cache_TBE*
Cache_Controller::nullTBE()
{
return NULL;

}
Cache_TBE*
Cache_Controller::getDvmTBE(const Addr& param_txnId)
{
Cache_TBE* dvm_tbe
 = (((*m_dvmTBEs_ptr)).lookup(param_txnId));
    if ((dvm_tbe != NULL)) {
        return dvm_tbe;
    }
    Cache_TBE* dvm_snp_tbe
     = (((*m_dvmSnpTBEs_ptr)).lookup(param_txnId));
        if ((dvm_snp_tbe != NULL)) {
            return dvm_snp_tbe;
        }
        return NULL;

}
Cache_TBE*
Cache_Controller::getCurrentActiveTBE(const Addr& param_addr)
{
Cache_TBE* snp_tbe
 = (((*m_snpTBEs_ptr)).lookup(param_addr));
    if ((snp_tbe != NULL)) {
        return snp_tbe;
    }
    Cache_TBE* req_tbe
     = (((*m_TBEs_ptr)).lookup(param_addr));
    Cache_TBE* repl_tbe
     = (((*m_replTBEs_ptr)).lookup(param_addr));
        if ((req_tbe != NULL)) {
            #ifndef NDEBUG
            if (!((repl_tbe == NULL))) {
                panic("Runtime Error at CHI-cache-funcs.sm:146: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            return req_tbe;
        }
            if ((repl_tbe != NULL)) {
                #ifndef NDEBUG
                if (!((req_tbe == NULL))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:150: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                return repl_tbe;
            }
            return NULL;

}
AccessPermission
Cache_Controller::getAccessPermission(const Addr& param_addr)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
    if ((tbe != NULL)) {
        #ifndef NDEBUG
        if (!(((Cache_State_to_permission((*tbe).m_state)) == AccessPermission_Busy))) {
            panic("Runtime Error at CHI-cache-funcs.sm:159: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        bool cu_requester_or_responder
         = (((*tbe).m_reqType == CHIRequestType_CleanUnique) || ((*tbe).m_pendReqType == CHIRequestType_CleanUnique));
            if ((((((*tbe).m_expected_req_resp).hasExpected()) || (((*tbe).m_expected_snp_resp).hasExpected())) && (! cu_requester_or_responder))) {
                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:169: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Busy);
                return AccessPermission_Busy;
            } else {
                    if (((*tbe).m_dataValid && ((*tbe).m_dataMaybeDirtyUpstream == (false)))) {
                            if ((*tbe).m_dataUnique) {
                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:174: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Read_Write);
                                return AccessPermission_Read_Write;
                            } else {
                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:177: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Read_Only);
                                return AccessPermission_Read_Only;
                            }
                        } else {
                            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:181: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Busy);
                            return AccessPermission_Busy;
                        }
                    }
                }
                Cache_CacheEntry* cache_entry
                 = (getCacheEntry(param_addr));
                    if ((cache_entry != NULL)) {
                        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:187: %x %s,%s\n", param_addr, (*cache_entry).m_state, (Cache_State_to_permission((*cache_entry).m_state)));
                        return (Cache_State_to_permission((*cache_entry).m_state));
                    }
                    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:190: %x %s,%s\n", param_addr, Cache_State_I, AccessPermission_NotPresent);
                    return AccessPermission_NotPresent;

}
void
Cache_Controller::setAccessPermission(Cache_CacheEntry* param_cache_entry, const Addr& param_addr, const Cache_State& param_state)
{
    if ((param_cache_entry != NULL)) {
        ((*(param_cache_entry)).changePermission((Cache_State_to_permission(param_state))));
    }

}
void
Cache_Controller::functionalRead(const Addr& param_addr, Packet* param_pkt, WriteMask& param_mask)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
Cache_CacheEntry* cache_entry
 = (getCacheEntry(param_addr));
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:205: functionalRead %x\n", param_addr);
WriteMask read_mask;
((read_mask).setBlockSize(((param_mask).getBlockSize())));
bool dirty
 = (false);
bool from_tbe
 = (false);
    if ((tbe != NULL)) {
        from_tbe = (true);
        dirty = (*tbe).m_dataDirty;
            if ((*tbe).m_dataValid) {
                ((read_mask).fillMask());
            } else {
                read_mask = (*tbe).m_dataBlkValid;
                dirty = ((((((((((((((dirty || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CompData_UD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CompData_SD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CBWrData_UD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CBWrData_SD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_NCBWrData))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_UD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_Fwded_SD_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_PD_Fwded_SC))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SD_Fwded_SC))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_Fwded_SD_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_PD_Fwded_SC)));
            }
        } else {
                if (((cache_entry != NULL) && (((Cache_State_to_permission((*cache_entry).m_state)) == AccessPermission_Read_Write) || ((Cache_State_to_permission((*cache_entry).m_state)) == AccessPermission_Read_Only)))) {
                    from_tbe = (false);
                    ((read_mask).fillMask());
                    dirty = (((((((((*cache_entry).m_state == Cache_State_UD) || ((*cache_entry).m_state == Cache_State_UD_RSC)) || ((*cache_entry).m_state == Cache_State_SD)) || ((*cache_entry).m_state == Cache_State_SD_RSC)) || ((*cache_entry).m_state == Cache_State_UD_RU)) || ((*cache_entry).m_state == Cache_State_UD_RSD)) || ((*cache_entry).m_state == Cache_State_SD_RSD)) || ((*cache_entry).m_state == Cache_State_UD_T));
                }
            }
            WriteMask test_mask
             = param_mask;
            ((test_mask).orMask(read_mask));
                if (((((param_mask).containsMask(test_mask)) == (false)) || dirty)) {
                        if (from_tbe) {
                                if ((testAndReadMask(param_addr, (*tbe).m_dataBlk, read_mask, param_pkt))) {
                                    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:252: functionalRead tbe %x %s dirty=%d %s %s\n", param_addr, (*tbe).m_dataBlk, (*tbe).m_dataDirty, read_mask, param_mask);
                                    ((param_mask).orMask(read_mask));
                                }
                            } else {
                                    if ((testAndReadMask(param_addr, (*cache_entry).m_DataBlk, read_mask, param_pkt))) {
                                        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:257: functionalRead cache %x %s dirty=%d %s %s\n", param_addr, (*cache_entry).m_DataBlk, dirty, read_mask, param_mask);
                                        ((param_mask).orMask(read_mask));
                                    }
                                }
                            }

}
int
Cache_Controller::functionalWrite(const Addr& param_addr, Packet* param_pkt)
{
int num_functional_writes
 = (0);
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
    if ((tbe != NULL)) {
        num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*tbe).m_dataBlk, param_pkt)));
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:270: functionalWrite tbe %x %s\n", param_addr, (*tbe).m_dataBlk);
    }
    Cache_CacheEntry* cache_entry
     = (getCacheEntry(param_addr));
        if ((cache_entry != NULL)) {
            num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*cache_entry).m_DataBlk, param_pkt)));
            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:276: functionalWrite cache %x %s\n", param_addr, (*cache_entry).m_DataBlk);
        }
        return num_functional_writes;

}
Cycles
Cache_Controller::mandatoryQueueLatency(const RubyRequestType& param_type)
{
return (intToCycles((1)));

}
Cycles
Cache_Controller::tagLatency(const bool& param_from_sequencer)
{
    if (param_from_sequencer) {
        return ((((*m_cache_ptr)).getTagLatency()) - (intToCycles((1))));
    } else {
        return (((*m_cache_ptr)).getTagLatency());
    }

}
Cycles
Cache_Controller::dataLatency()
{
return (((*m_cache_ptr)).getDataLatency());

}
bool
Cache_Controller::fromSequencer(const CHIRequestType& param_reqType)
{
return (((((param_reqType == CHIRequestType_Load) || (param_reqType == CHIRequestType_Store)) || (param_reqType == CHIRequestType_StoreLine)) || (param_reqType == CHIRequestType_AtomicLoad)) || (param_reqType == CHIRequestType_AtomicStore));

}
void
Cache_Controller::regProbePoints()
{
(((*m_pfProxy_ptr)).regProbePoints());

}
bool
Cache_Controller::inCache(const Addr& param_addr, const bool& param_is_secure)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((((entry != NULL) == (false)) || ((*entry).m_state == Cache_State_I))) {
        return (false);
    } else {
        return (true);
    }

}
bool
Cache_Controller::hasBeenPrefetched(const Addr& param_addr, const bool& param_is_secure, const RequestorID& param_requestor)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((entry != NULL)) {
        return ((*entry).m_HWPrefetched && ((*entry).m_requestor == param_requestor));
    } else {
        return (false);
    }

}
bool
Cache_Controller::hasBeenPrefetched(const Addr& param_addr, const bool& param_is_secure)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((entry != NULL)) {
        return (*entry).m_HWPrefetched;
    } else {
        return (false);
    }

}
bool
Cache_Controller::inMissQueue(const Addr& param_addr, const bool& param_is_secure)
{
Addr line_addr
 = (makeLineAddress(param_addr));
Cache_TBE* tbe
 = (getCurrentActiveTBE(line_addr));
return (tbe != NULL);

}
bool
Cache_Controller::coalesce()
{
return (false);

}
void
Cache_Controller::notifyCoalesced(const Addr& param_addr, const RubyRequestType& param_type, const RequestPtr& param_req, const DataBlock& param_data_blk, const bool& param_was_miss)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:351: notifyCoalesced(addr=%#x, type=%s, was_miss=%d)\n", param_addr, param_type, param_was_miss);
    if (param_was_miss) {
        (((*m_cache_ptr)).profileDemandMiss());
    } else {
        (((*m_cache_ptr)).profileDemandHit());
    }
        if (m_use_prefetcher) {
            bool is_read
             = (((param_type == RubyRequestType_LD) || (param_type == RubyRequestType_Load_Linked)) || (param_type == RubyRequestType_IFETCH));
                if (param_was_miss) {
                    (((*m_pfProxy_ptr)).notifyPfMiss(param_req, is_read, param_data_blk));
                } else {
                    (((*m_pfProxy_ptr)).notifyPfHit(param_req, is_read, param_data_blk));
                }
            }

}
void
Cache_Controller::clearExpectedReqResp(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:376: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:377: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*param_tbe).m_expected_req_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
Cache_Controller::clearExpectedSnpResp(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:382: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:383: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*param_tbe).m_expected_snp_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
Cache_Controller::initializeTBE(Cache_TBE* param_tbe, const Addr& param_addr, const int& param_storSlot)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:388: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*param_tbe).m_wakeup_pending_req = (false);
(*param_tbe).m_wakeup_pending_snp = (false);
(*param_tbe).m_wakeup_pending_tgr = (false);
(*param_tbe).m_addr = param_addr;
(*param_tbe).m_storSlot = param_storSlot;
(clearExpectedReqResp(param_tbe));
(clearExpectedSnpResp(param_tbe));
(*param_tbe).m_defer_expected_comp = (false);
(*param_tbe).m_requestorToBeOwner = (false);
(*param_tbe).m_requestorToBeExclusiveOwner = (false);
(*param_tbe).m_updateDirOnCompAck = (true);
(*param_tbe).m_dataToBeInvalid = (false);
(*param_tbe).m_dataToBeSharedClean = (false);
(*param_tbe).m_doCacheFill = (false);
(*param_tbe).m_pendReqType = CHIRequestType_null;
(*param_tbe).m_pendAction = Cache_Event_null;
(*param_tbe).m_finalState = Cache_State_null;
(*param_tbe).m_delayNextAction = (intToTick((0)));
(*param_tbe).m_is_stale = (false);

}
Cache_TBE*
Cache_Controller::allocateRequestTBE(const Addr& param_addr, const CHIRequestMsg& param_in_msg)
{
(((*m_storTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:423: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_TBEs_ptr)).allocate(param_addr));
Cache_TBE* tbe
 = (((*m_TBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, (((*m_storTBEs_ptr)).addEntryToNewSlot())));
    if ((fromSequencer((param_in_msg).m_type))) {
        #ifndef NDEBUG
        if (!(((param_in_msg).m_txnId == m_max_outstanding_transactions))) {
            panic("Runtime Error at CHI-cache-funcs.sm:430: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*tbe).m_txnId = static_cast<Addr >((*tbe).m_storSlot)
        ;
    } else {
        (*tbe).m_txnId = (param_in_msg).m_txnId;
    }
    (*tbe).m_ns = (param_in_msg).m_ns;
    #ifndef NDEBUG
    if (!(((*tbe).m_is_snp_tbe == (false)))) {
        panic("Runtime Error at CHI-cache-funcs.sm:437: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!(((*tbe).m_is_repl_tbe == (false)))) {
        panic("Runtime Error at CHI-cache-funcs.sm:438: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!(((*tbe).m_is_dvm_tbe == (false)))) {
        panic("Runtime Error at CHI-cache-funcs.sm:439: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!(((*tbe).m_is_dvm_snp_tbe == (false)))) {
        panic("Runtime Error at CHI-cache-funcs.sm:440: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    (*tbe).m_is_req_tbe = (true);
    (*tbe).m_accAddr = (param_in_msg).m_accAddr;
    (*tbe).m_accSize = (param_in_msg).m_accSize;
    (*tbe).m_requestor = (param_in_msg).m_requestor;
    (*tbe).m_reqType = (param_in_msg).m_type;
    (*tbe).m_isSeqReqValid = (param_in_msg).m_isSeqReqValid;
    (*tbe).m_seqReq = (param_in_msg).m_seqReq;
    (*tbe).m_is_local_pf = (param_in_msg).m_is_local_pf;
    (*tbe).m_is_remote_pf = (param_in_msg).m_is_remote_pf;
    (((*tbe).m_atomic_op).clear());
    (((*tbe).m_atomic_op).orMask((param_in_msg).m_atomic_op));
    (*tbe).m_atomic_to_be_done = (false);
    (*tbe).m_atomic_to_be_wb = (false);
    (*tbe).m_use_DMT = (false);
    (*tbe).m_use_DCT = (false);
    (*tbe).m_hasUseTimeout = (false);
    return tbe;

}
Cache_TBE*
Cache_Controller::allocateDvmRequestTBE(const Addr& param_txnId, const CHIRequestMsg& param_in_msg)
{
(((*m_storDvmTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storDvmTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:469: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_dvmTBEs_ptr)).allocate(param_txnId));
Cache_TBE* tbe
 = (((*m_dvmTBEs_ptr)).lookup(param_txnId));
(initializeTBE(tbe, param_txnId, (((*m_storDvmTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:477: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:478: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:479: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:480: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*tbe).m_is_dvm_tbe = (true);
(*tbe).m_accAddr = param_txnId;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_isSeqReqValid = (param_in_msg).m_isSeqReqValid;
(*tbe).m_seqReq = (param_in_msg).m_seqReq;
(*tbe).m_is_local_pf = (param_in_msg).m_is_local_pf;
(*tbe).m_is_remote_pf = (param_in_msg).m_is_remote_pf;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
(*tbe).m_hasUseTimeout = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateSnoopTBE(const Addr& param_addr, const CHIRequestMsg& param_in_msg)
{
(((*m_storSnpTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storSnpTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:505: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_snpTBEs_ptr)).allocate(param_addr));
Cache_TBE* tbe
 = (((*m_snpTBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, (((*m_storSnpTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:511: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:512: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:513: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:514: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*tbe).m_is_snp_tbe = (true);
(*tbe).m_accAddr = param_addr;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_fwdRequestor = (param_in_msg).m_fwdRequestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_txnId = (param_in_msg).m_txnId;
(*tbe).m_snpNeedsData = (param_in_msg).m_retToSrc;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateDvmSnoopTBE(const Addr& param_txnId, const CHIRequestMsg& param_in_msg)
{
(((*m_storDvmSnpTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storDvmSnpTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:535: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_dvmSnpTBEs_ptr)).allocate(param_txnId));
Cache_TBE* tbe
 = (((*m_dvmSnpTBEs_ptr)).lookup(param_txnId));
(initializeTBE(tbe, param_txnId, (((*m_storDvmSnpTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:541: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:542: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:543: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:544: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*tbe).m_is_dvm_snp_tbe = (true);
(*tbe).m_accAddr = param_txnId;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_fwdRequestor = (param_in_msg).m_fwdRequestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_snpNeedsData = (param_in_msg).m_retToSrc;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::_allocateReplacementTBE(const Addr& param_addr, const int& param_storSlot)
{
Cache_TBE* tbe
 = (((*m_replTBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, param_storSlot));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:566: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:567: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:568: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*tbe).m_is_repl_tbe = (true);
(*tbe).m_accAddr = param_addr;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = m_machineID;
(*tbe).m_reqType = CHIRequestType_null;
(*tbe).m_txnId = static_cast<Addr >(param_storSlot)
;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateReplacementTBE(const Addr& param_addr)
{
#ifndef NDEBUG
if (!((((*m_storReplTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:586: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_replTBEs_ptr)).allocate(param_addr));
return (_allocateReplacementTBE(param_addr, (((*m_storReplTBEs_ptr)).addEntryToNewSlot())));

}
Cache_TBE*
Cache_Controller::allocateReplacementTBEOnSlot(const Addr& param_addr, const int& param_slot)
{
#ifndef NDEBUG
if (!(m_unify_repl_TBEs)) {
    panic("Runtime Error at CHI-cache-funcs.sm:594: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_storTBEs_ptr)).addEntryToSlot(param_slot));
(((*m_replTBEs_ptr)).allocate(param_addr));
return (_allocateReplacementTBE(param_addr, param_slot));

}
Cache_TBE*
Cache_Controller::getHazardTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:602: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:603: %s for machine %s.\n", "assert failure", name());

}
#endif
;
Cache_TBE* hazard_tbe
 = (((*m_TBEs_ptr)).lookup((*param_tbe).m_addr));
    if ((*param_tbe).m_is_req_hazard) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_is_repl_hazard == (false)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:606: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
    } else {
        #ifndef NDEBUG
        if (!((*param_tbe).m_is_repl_hazard)) {
            panic("Runtime Error at CHI-cache-funcs.sm:608: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        hazard_tbe = (((*m_replTBEs_ptr)).lookup((*param_tbe).m_addr));
    }
    #ifndef NDEBUG
    if (!((hazard_tbe != NULL))) {
        panic("Runtime Error at CHI-cache-funcs.sm:611: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    return hazard_tbe;

}
void
Cache_Controller::scheduleSendData(Cache_TBE* param_tbe, const int& param_when)
{
    if (((((*param_tbe).m_snd_pendBytes).count()) > (0))) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_snd_pendEv == (false)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:617: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*param_tbe).m_snd_pendEv = (true);
        (*param_tbe).m_pendAction = Cache_Event_TX_Data;
        {
            std::shared_ptr<Cache_TriggerMsg> out_msg = std::make_shared<Cache_TriggerMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            (*out_msg).m_addr = (*param_tbe).m_addr;
            (*out_msg).m_from_hazard = ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard);
            ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((intToCycles(param_when)))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
    }

}
void
Cache_Controller::setupPendingSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:629: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:630: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*param_tbe).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-funcs.sm:632: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*param_tbe).m_snd_pendBytes).fillMask());
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::setupPendingPartialSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:638: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:639: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*param_tbe).m_dataBlkValid).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:641: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*param_tbe).m_snd_pendBytes = (*param_tbe).m_dataBlkValid;
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::setupPendingAtomicSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:647: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:648: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*param_tbe).m_snd_pendBytes).setMask((0), (*param_tbe).m_accSize, (true)));
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::prepareRequest(Cache_TBE* param_tbe, const CHIRequestType& param_type, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_accAddr = (*param_tbe).m_addr;
(param_out_msg).m_accSize = (*m_blockSize_ptr);
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_type = param_type;
(param_out_msg).m_allowRetry = (false);
(*param_tbe).m_pendReqAllowRetry = (false);
(*param_tbe).m_rcvdRetryAck = (false);
(*param_tbe).m_rcvdRetryCredit = (false);
(*param_tbe).m_pendReqType = param_type;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);
(param_out_msg).m_txnId = (*param_tbe).m_txnId;
#ifndef NDEBUG
if (!(((*param_tbe).m_txnId != static_cast<Addr >((- (1)))
))) {
    panic("Runtime Error at CHI-cache-funcs.sm:672: %s for machine %s.\n", "assert failure", name());

}
#endif
;

}
void
Cache_Controller::prepareRequestAtomic(Cache_TBE* param_tbe, const CHIRequestType& param_type, CHIRequestMsg& param_out_msg)
{
#ifndef NDEBUG
if (!(((param_type == CHIRequestType_AtomicReturn) || (param_type == CHIRequestType_AtomicNoReturn)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:678: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(prepareRequest(param_tbe, param_type, param_out_msg));
(param_out_msg).m_accAddr = (*param_tbe).m_accAddr;
(param_out_msg).m_accSize = (*param_tbe).m_accSize;
(((param_out_msg).m_atomic_op).clear());
(((param_out_msg).m_atomic_op).orMask((*param_tbe).m_atomic_op));

}
void
Cache_Controller::allowRequestRetry(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_allowRetry = (true);
(*param_tbe).m_pendReqAllowRetry = (true);
(*param_tbe).m_pendReqAccAddr = (param_out_msg).m_accAddr;
(*param_tbe).m_pendReqAccSize = (param_out_msg).m_accSize;
(*param_tbe).m_pendReqDest = (param_out_msg).m_Destination;
(*param_tbe).m_pendReqD2OrigReq = (param_out_msg).m_dataToFwdRequestor;
(*param_tbe).m_pendReqRetToSrc = (param_out_msg).m_retToSrc;

}
void
Cache_Controller::prepareRequestRetry(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
#ifndef NDEBUG
if (!((*param_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-funcs.sm:697: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*param_tbe).m_pendReqAllowRetry = (false);
(param_out_msg).m_allowRetry = (false);
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_accAddr = (*param_tbe).m_pendReqAccAddr;
(param_out_msg).m_accSize = (*param_tbe).m_pendReqAccSize;
(param_out_msg).m_type = (*param_tbe).m_pendReqType;
(param_out_msg).m_Destination = (*param_tbe).m_pendReqDest;
(param_out_msg).m_dataToFwdRequestor = (*param_tbe).m_pendReqD2OrigReq;
(param_out_msg).m_retToSrc = (*param_tbe).m_pendReqRetToSrc;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);
(((param_out_msg).m_atomic_op).clear());
(((param_out_msg).m_atomic_op).orMask((*param_tbe).m_atomic_op));

}
void
Cache_Controller::prepareRequestRetryDVM(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
#ifndef NDEBUG
if (!((*param_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-funcs.sm:719: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*param_tbe).m_pendReqAllowRetry = (false);
(param_out_msg).m_allowRetry = (false);
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_usesTxnId = (true);
(param_out_msg).m_txnId = (*param_tbe).m_addr;
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_accAddr = (*param_tbe).m_pendReqAccAddr;
(param_out_msg).m_accSize = (*param_tbe).m_pendReqAccSize;
(param_out_msg).m_type = (*param_tbe).m_pendReqType;
(param_out_msg).m_Destination = (*param_tbe).m_pendReqDest;
(param_out_msg).m_dataToFwdRequestor = (*param_tbe).m_pendReqD2OrigReq;
(param_out_msg).m_retToSrc = (*param_tbe).m_pendReqRetToSrc;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);

}
void
Cache_Controller::enqueueDoRetry(Cache_TBE* param_tbe)
{
    if (((*param_tbe).m_rcvdRetryAck && (*param_tbe).m_rcvdRetryCredit)) {
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            (*out_msg).m_addr = (*param_tbe).m_addr;
            (*out_msg).m_usesTxnId = ((*param_tbe).m_is_dvm_tbe || (*param_tbe).m_is_dvm_snp_tbe);
            (*out_msg).m_event = Cache_Event_DoRetry;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
        (((*m_destsWaitingRetry_ptr)).removeNetDest((*param_tbe).m_pendReqDest));
    }

}
void
Cache_Controller::processRetryQueue()
{
bool has_avail
 = (((*m_storTBEs_ptr)).areNSlotsAvailable((1)));
#ifndef NDEBUG
if (!((m_unify_repl_TBEs || has_avail))) {
    panic("Runtime Error at CHI-cache-funcs.sm:754: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((((((*m_retryQueue_ptr)).empty()) == (false)) && has_avail)) {
        (((*m_storTBEs_ptr)).incrementReserved());
        Cache_RetryQueueEntry e
         = (((*m_retryQueue_ptr)).next());
        (((*m_retryQueue_ptr)).pop());
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
            (*out_msg).m_addr = (e).m_addr;
            (*out_msg).m_usesTxnId = (e).m_usesTxnId;
            (*out_msg).m_retryDest = (e).m_retryDest;
            (*out_msg).m_event = Cache_Event_SendPCrdGrant;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
        }
    }

}
void
Cache_Controller::printResources()
{
    if (m_unify_repl_TBEs) {
        #ifndef NDEBUG
        if (!(((((*m_storReplTBEs_ptr)).size()) == (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:771: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((((*m_storReplTBEs_ptr)).reserved()) == (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:772: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:773: Resources(used/rsvd/max): TBEs=%d/%d/%d snpTBEs=%d/%d/%d replTBEs=%d/%d/%d dvmTBEs=%d/%d/%d\n", (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storSnpTBEs_ptr)).size()), (((*m_storSnpTBEs_ptr)).reserved()), (((*m_storSnpTBEs_ptr)).capacity()), (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storDvmTBEs_ptr)).size()), (((*m_storDvmTBEs_ptr)).reserved()), (((*m_storDvmTBEs_ptr)).capacity()));
    } else {
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:779: Resources(used/rsvd/max): TBEs=%d/%d/%d snpTBEs=%d/%d/%d replTBEs=%d/%d/%d dvmTBEs=%d/%d/%d\n", (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storSnpTBEs_ptr)).size()), (((*m_storSnpTBEs_ptr)).reserved()), (((*m_storSnpTBEs_ptr)).capacity()), (((*m_storReplTBEs_ptr)).size()), (((*m_storReplTBEs_ptr)).reserved()), (((*m_storReplTBEs_ptr)).capacity()), (((*m_storDvmTBEs_ptr)).size()), (((*m_storDvmTBEs_ptr)).reserved()), (((*m_storDvmTBEs_ptr)).capacity()));
    }
    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:785: Resources(in/out size): req=%d/%d rsp=%d/%d dat=%d/%d snp=%d/%d trigger=%d\n", (((*m_reqIn_ptr)).getSize((curTick()))), (((*m_reqOut_ptr)).getSize((curTick()))), (((*m_rspIn_ptr)).getSize((curTick()))), (((*m_rspOut_ptr)).getSize((curTick()))), (((*m_datIn_ptr)).getSize((curTick()))), (((*m_datOut_ptr)).getSize((curTick()))), (((*m_snpIn_ptr)).getSize((curTick()))), (((*m_snpOut_ptr)).getSize((curTick()))), (((*m_triggerQueue_ptr)).getSize((curTick()))));

}
bool
Cache_Controller::needCacheEntry(const CHIRequestType& param_req_type, Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry, const bool& param_is_prefetch)
{
    if (((param_cache_entry != NULL) || ((m_enable_DMT && (param_dir_entry == NULL)) && ((((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadUnique)) || (param_req_type == CHIRequestType_MakeReadUnique)) || (param_req_type == CHIRequestType_ReadOnce))))) {
        return (false);
    } else {
        return (((((((param_is_prefetch || (m_alloc_on_readshared && ((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadNotSharedDirty)))) || (m_alloc_on_readunique && ((param_req_type == CHIRequestType_ReadUnique) || (param_req_type == CHIRequestType_MakeReadUnique)))) || (m_alloc_on_readonce && (param_req_type == CHIRequestType_ReadOnce))) || (m_alloc_on_writeback && ((((param_req_type == CHIRequestType_WriteBackFull) || (param_req_type == CHIRequestType_WriteCleanFull)) || (param_req_type == CHIRequestType_WriteEvictFull)) || (m_is_HN && (param_req_type == CHIRequestType_WriteUniqueFull))))) || (m_alloc_on_seq_acc && ((((param_req_type == CHIRequestType_Load) || (param_req_type == CHIRequestType_Store)) || (param_req_type == CHIRequestType_AtomicLoad)) || (param_req_type == CHIRequestType_AtomicStore)))) || (m_alloc_on_seq_line_write && (param_req_type == CHIRequestType_StoreLine))) || (m_alloc_on_atomic && ((param_req_type == CHIRequestType_AtomicReturn) || (param_req_type == CHIRequestType_AtomicNoReturn))));
    }

}
bool
Cache_Controller::needDeallocCacheEntry(const CHIRequestType& param_req_type)
{
return ((m_dealloc_on_shared && ((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadNotSharedDirty))) || (m_dealloc_on_unique && (((param_req_type == CHIRequestType_ReadUnique) || (param_req_type == CHIRequestType_MakeReadUnique)) || (param_req_type == CHIRequestType_CleanUnique))));

}
bool
Cache_Controller::upstreamHasUnique(const Cache_State& param_state)
{
return (((param_state == Cache_State_RU) || (param_state == Cache_State_UD_RU)) || (param_state == Cache_State_UC_RU));

}
bool
Cache_Controller::upstreamHasShared(const Cache_State& param_state)
{
return ((((((((((param_state == Cache_State_RSC) || (param_state == Cache_State_RSD)) || (param_state == Cache_State_RUSD)) || (param_state == Cache_State_RUSC)) || (param_state == Cache_State_UD_RSD)) || (param_state == Cache_State_SD_RSD)) || (param_state == Cache_State_UD_RSC)) || (param_state == Cache_State_SD_RSC)) || (param_state == Cache_State_UC_RSC)) || (param_state == Cache_State_SC_RSC));

}
void
Cache_Controller::printTBEState(Cache_TBE* param_tbe)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:849: STATE: addr: %#x data present=%d valid=%d unique=%d dirty=%d mu_dirty=%d dir ownerV=%d ownerE=%d sharers=%d tobe_I=%d tobe_SC=%d doFill=%d pendAction=%s txnId=%d\n", (*param_tbe).m_addr, (((*param_tbe).m_dataBlkValid).isFull()), (*param_tbe).m_dataValid, (*param_tbe).m_dataUnique, (*param_tbe).m_dataDirty, (*param_tbe).m_dataMaybeDirtyUpstream, (*param_tbe).m_dir_ownerExists, (*param_tbe).m_dir_ownerIsExcl, (((*param_tbe).m_dir_sharers).count()), (*param_tbe).m_dataToBeInvalid, (*param_tbe).m_dataToBeSharedClean, (*param_tbe).m_doCacheFill, (*param_tbe).m_pendAction, (*param_tbe).m_txnId);
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:855: dataBlkValid = %s\n", (*param_tbe).m_dataBlkValid);

}
void
Cache_Controller::printDvmTBEState(Cache_TBE* param_tbe)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:859: STATE: addr=%#x reqType=%d state=%d pendAction=%s isDvmTBE=%d isReplTBE=%d isReqTBE=%d isSnpTBE=%d\n", (*param_tbe).m_addr, (*param_tbe).m_reqType, (*param_tbe).m_state, (*param_tbe).m_pendAction, (*param_tbe).m_is_dvm_tbe, (*param_tbe).m_is_repl_tbe, (*param_tbe).m_is_req_tbe, (*param_tbe).m_is_snp_tbe);

}
MachineID
Cache_Controller::getMiscNodeMachine()
{
return (mapAddressToMachine((intToAddress((0))), MachineType_MiscNode));

}
void
Cache_Controller::copyCacheAndDir(Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry, Cache_TBE* param_tbe, const Cache_State& param_initialState)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:871: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((param_dir_entry != NULL)) {
        #ifndef NDEBUG
        if (!((((((((((((((param_initialState == Cache_State_UD_RSC) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_SC_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RSC)) || (param_initialState == Cache_State_RSD)) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_RUSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:881: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        (*param_tbe).m_dir_sharers = (*param_dir_entry).m_sharers;
        (*param_tbe).m_dir_owner = (*param_dir_entry).m_owner;
        (*param_tbe).m_dir_ownerExists = (*param_dir_entry).m_ownerExists;
        (*param_tbe).m_dir_ownerIsExcl = (*param_dir_entry).m_ownerIsExcl;
        #ifndef NDEBUG
        if (!(((((*param_tbe).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:886: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
    } else {
        (((*param_tbe).m_dir_sharers).clear());
        (*param_tbe).m_dir_ownerExists = (false);
    }
    #ifndef NDEBUG
    if (!((((*param_tbe).m_dir_ownerExists && (*param_tbe).m_dir_ownerIsExcl) == (((param_initialState == Cache_State_UD_RU) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU))))) {
        panic("Runtime Error at CHI-cache-funcs.sm:894: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!((((*param_tbe).m_dir_ownerExists && ((*param_tbe).m_dir_ownerIsExcl == (false))) == ((((param_initialState == Cache_State_RSD) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD))))) {
        panic("Runtime Error at CHI-cache-funcs.sm:897: %s for machine %s.\n", "assert failure", name());

    }
    #endif
    ;
        if (((param_cache_entry != NULL) && (((((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_SD)) || (param_initialState == Cache_State_UC)) || (param_initialState == Cache_State_SC)) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_SC_RSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_UD_T)))) {
            (*param_tbe).m_dataBlk = (*param_cache_entry).m_DataBlk;
            (((*param_tbe).m_dataBlkValid).fillMask());
            (*param_tbe).m_dataValid = (true);
            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:910: Cached data %s\n", (*param_tbe).m_dataBlk);
        } else {
            #ifndef NDEBUG
            if (!(((param_cache_entry == NULL) || (((param_cache_entry != NULL) && (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC_RU))))) {
                panic("Runtime Error at CHI-cache-funcs.sm:914: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            (((*param_tbe).m_dataBlkValid).clear());
            (*param_tbe).m_dataValid = (false);
        }
            if (((param_cache_entry != NULL) && (((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf) == (false)))) {
                (((*m_cache_ptr)).setMRU(param_cache_entry));
            }
            (*param_tbe).m_dataDirty = ((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_SD)) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_UD_T));
            (*param_tbe).m_dataMaybeDirtyUpstream = (((((((param_initialState == Cache_State_UD_RU) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RSD)) || (param_initialState == Cache_State_RUSD));
            #ifndef NDEBUG
            if (!(((*param_tbe).m_dir_ownerExists == (*param_tbe).m_dataMaybeDirtyUpstream))) {
                panic("Runtime Error at CHI-cache-funcs.sm:935: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            (*param_tbe).m_dataUnique = (((((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_RUSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_UD_T));
            (*param_tbe).m_hasUseTimeout = (param_initialState == Cache_State_UD_T);
            (*param_tbe).m_dataToBeSharedClean = (false);
            (*param_tbe).m_dataToBeInvalid = (false);
            (printTBEState(param_tbe));

}
void
Cache_Controller::copyCacheAndDirTBEs(Cache_TBE* param_src, Cache_TBE* param_dst)
{
#ifndef NDEBUG
if (!((param_src != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:955: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((param_dst != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:956: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*param_dst).m_dataBlk = (*param_src).m_dataBlk;
(*param_dst).m_dataBlkValid = (*param_src).m_dataBlkValid;
(*param_dst).m_dataValid = (*param_src).m_dataValid;
(*param_dst).m_dataDirty = (*param_src).m_dataDirty;
(*param_dst).m_dataMaybeDirtyUpstream = (*param_src).m_dataMaybeDirtyUpstream;
(*param_dst).m_dataUnique = (*param_src).m_dataUnique;
(*param_dst).m_dir_sharers = (*param_src).m_dir_sharers;
(*param_dst).m_dir_owner = (*param_src).m_dir_owner;
(*param_dst).m_dir_ownerExists = (*param_src).m_dir_ownerExists;
(*param_dst).m_dir_ownerIsExcl = (*param_src).m_dir_ownerIsExcl;
(printTBEState(param_dst));

}
void
Cache_Controller::deallocateReqTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:971: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_req_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:972: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_storTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_TBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateSnpTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:978: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:979: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_storSnpTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_snpTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateReplacementTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:985: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_repl_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:986: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if (m_unify_repl_TBEs) {
        (((*m_storTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
    } else {
        (((*m_storReplTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
    }
    (((*m_replTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateDvmTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:996: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:997: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_storDvmTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_dvmTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateDvmSnoopTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1003: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_dvm_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:1004: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(((*m_storDvmSnpTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_dvmSnpTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::setDataToBeStates(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1010: %s for machine %s.\n", "assert failure", name());

}
#endif
;
    if ((*param_tbe).m_dataToBeInvalid) {
        (*param_tbe).m_dataValid = (false);
        (((*param_tbe).m_dataBlkValid).clear());
    }
        if ((*param_tbe).m_dataToBeSharedClean) {
            (*param_tbe).m_dataUnique = (false);
            (*param_tbe).m_dataDirty = (false);
            #ifndef NDEBUG
            if (!(((*param_tbe).m_dataMaybeDirtyUpstream == (false)))) {
                panic("Runtime Error at CHI-cache-funcs.sm:1018: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
        }
        (*param_tbe).m_dataToBeInvalid = (false);
        (*param_tbe).m_dataToBeSharedClean = (false);

}
void
Cache_Controller::setExpectedForInvSnoop(Cache_TBE* param_tbe, const bool& param_expectCleanWB)
{
#ifndef NDEBUG
if (!(((((*param_tbe).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1025: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((((*param_tbe).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1026: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(clearExpectedSnpResp(param_tbe));
    if (param_expectCleanWB) {
        (((*param_tbe).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I));
    }
        if ((*param_tbe).m_dataMaybeDirtyUpstream) {
            #ifndef NDEBUG
            if (!((*param_tbe).m_dir_ownerExists)) {
                panic("Runtime Error at CHI-cache-funcs.sm:1032: %s for machine %s.\n", "assert failure", name());

            }
            #endif
            ;
            (((*param_tbe).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_PD));
                if (((param_expectCleanWB == (false)) || ((((*param_tbe).m_dir_sharers).count()) > (1)))) {
                    (((*param_tbe).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
                }
            } else {
                (((*param_tbe).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
            }
            (((*param_tbe).m_expected_snp_resp).setExpectedCount((((*param_tbe).m_dir_sharers).count())));

}
Cache_State
Cache_Controller::makeFinalStateHelper(const Cache_State& param_cs, const Cache_State& param_ds)
{
    if ((param_ds == Cache_State_RSC)) {
            if ((param_cs == Cache_State_UD)) {
                return Cache_State_UD_RSC;
            } else {
                    if ((param_cs == Cache_State_SD)) {
                        return Cache_State_SD_RSC;
                    } else {
                            if ((param_cs == Cache_State_UC)) {
                                return Cache_State_UC_RSC;
                            } else {
                                    if ((param_cs == Cache_State_SC)) {
                                        return Cache_State_SC_RSC;
                                    } else {
                                        return Cache_State_RSC;
                                    }
                                }
                            }
                        }
                    } else {
                            if ((param_ds == Cache_State_RU)) {
                                    if ((param_cs == Cache_State_UD)) {
                                        return Cache_State_UD_RU;
                                    } else {
                                            if ((param_cs == Cache_State_UC)) {
                                                return Cache_State_UC_RU;
                                            } else {
                                                #ifndef NDEBUG
                                                if (!((param_cs != Cache_State_SC))) {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:1062: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((param_cs != Cache_State_SD))) {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:1063: %s for machine %s.\n", "assert failure", name());

                                                }
                                                #endif
                                                ;
                                                return Cache_State_RU;
                                            }
                                        }
                                    } else {
                                            if ((param_ds == Cache_State_RSD)) {
                                                    if ((param_cs == Cache_State_UD)) {
                                                        return Cache_State_UD_RSD;
                                                    } else {
                                                            if ((param_cs == Cache_State_SD)) {
                                                                return Cache_State_SD_RSD;
                                                            } else {
                                                                #ifndef NDEBUG
                                                                if (!((param_cs == Cache_State_I))) {
                                                                    panic("Runtime Error at CHI-cache-funcs.sm:1072: %s for machine %s.\n", "assert failure", name());

                                                                }
                                                                #endif
                                                                ;
                                                                return Cache_State_RSD;
                                                            }
                                                        }
                                                    } else {
                                                            if ((param_ds == Cache_State_RUSD)) {
                                                                    if ((param_cs == Cache_State_UD)) {
                                                                        return Cache_State_UD_RSD;
                                                                    } else {
                                                                        #ifndef NDEBUG
                                                                        if (!((param_cs == Cache_State_I))) {
                                                                            panic("Runtime Error at CHI-cache-funcs.sm:1079: %s for machine %s.\n", "assert failure", name());

                                                                        }
                                                                        #endif
                                                                        ;
                                                                        return Cache_State_RUSD;
                                                                    }
                                                                } else {
                                                                        if ((param_ds == Cache_State_RUSC)) {
                                                                                if ((param_cs == Cache_State_UC)) {
                                                                                    return Cache_State_UC_RSC;
                                                                                } else {
                                                                                        if ((param_cs == Cache_State_UD)) {
                                                                                            return Cache_State_UD_RSC;
                                                                                        } else {
                                                                                            #ifndef NDEBUG
                                                                                            if (!((param_cs == Cache_State_I))) {
                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1088: %s for machine %s.\n", "assert failure", name());

                                                                                            }
                                                                                            #endif
                                                                                            ;
                                                                                            return Cache_State_RUSC;
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    #ifndef NDEBUG
                                                                                    if (!((param_ds == Cache_State_I))) {
                                                                                        panic("Runtime Error at CHI-cache-funcs.sm:1092: %s for machine %s.\n", "assert failure", name());

                                                                                    }
                                                                                    #endif
                                                                                    ;
                                                                                    return param_cs;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }

}
Cache_State
Cache_Controller::makeFinalState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry)
{
(setDataToBeStates(param_tbe));
(printTBEState(param_tbe));
Cache_State cache_state
 = Cache_State_I;
Cache_State dir_state
 = Cache_State_I;
    if ((*param_tbe).m_dir_ownerExists) {
        #ifndef NDEBUG
        if (!((param_dir_entry != NULL))) {
            panic("Runtime Error at CHI-cache-funcs.sm:1105: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*param_tbe).m_dataMaybeDirtyUpstream)) {
            panic("Runtime Error at CHI-cache-funcs.sm:1106: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
            if ((*param_tbe).m_dir_ownerIsExcl) {
                #ifndef NDEBUG
                if (!(((((*param_tbe).m_dir_sharers).count()) == (1)))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:1108: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                dir_state = Cache_State_RU;
            } else {
                #ifndef NDEBUG
                if (!(((((*param_tbe).m_dir_sharers).count()) >= (1)))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:1111: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                    if ((*param_tbe).m_dataUnique) {
                        dir_state = Cache_State_RUSD;
                    } else {
                        dir_state = Cache_State_RSD;
                    }
                }
            } else {
                    if (((((*param_tbe).m_dir_sharers).count()) > (0))) {
                        #ifndef NDEBUG
                        if (!((param_dir_entry != NULL))) {
                            panic("Runtime Error at CHI-cache-funcs.sm:1119: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*param_tbe).m_dataMaybeDirtyUpstream == (false)))) {
                            panic("Runtime Error at CHI-cache-funcs.sm:1120: %s for machine %s.\n", "assert failure", name());

                        }
                        #endif
                        ;
                            if ((*param_tbe).m_dataUnique) {
                                dir_state = Cache_State_RUSC;
                            } else {
                                dir_state = Cache_State_RSC;
                            }
                        }
                    }
                        if (((*param_tbe).m_dataValid && (param_cache_entry != NULL))) {
                                if (((*param_tbe).m_dataUnique && (*param_tbe).m_dataDirty)) {
                                        if ((*param_tbe).m_hasUseTimeout) {
                                            cache_state = Cache_State_UD_T;
                                        } else {
                                            cache_state = Cache_State_UD;
                                        }
                                    } else {
                                            if (((*param_tbe).m_dataUnique && ((*param_tbe).m_dataDirty == (false)))) {
                                                cache_state = Cache_State_UC;
                                            } else {
                                                    if ((((*param_tbe).m_dataUnique == (false)) && (*param_tbe).m_dataDirty)) {
                                                        #ifndef NDEBUG
                                                        if (!(m_allow_SD)) {
                                                            panic("Runtime Error at CHI-cache-funcs.sm:1138: %s for machine %s.\n", "assert failure", name());

                                                        }
                                                        #endif
                                                        ;
                                                        cache_state = Cache_State_SD;
                                                    } else {
                                                        cache_state = Cache_State_SC;
                                                    }
                                                }
                                            }
                                        }
                                        return (makeFinalStateHelper(cache_state, dir_state));

}
Cache_State
Cache_Controller::getNextState(const Addr& param_address)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_address));
#ifndef NDEBUG
if (!((tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1151: %s for machine %s.\n", "assert failure", name());

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_pendAction == Cache_Event_Final))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1152: %s for machine %s.\n", "assert failure", name());

}
#endif
;
(*tbe).m_finalState = (makeFinalState(tbe, (getCacheEntry(param_address)), (getDirEntry(param_address))));
#ifndef NDEBUG
if (!(((*tbe).m_finalState != Cache_State_null))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1154: %s for machine %s.\n", "assert failure", name());

}
#endif
;
return (*tbe).m_finalState;

}
int
Cache_Controller::scLockLatency()
{
return ((*m_sc_lock_multiplier_ptr) * m_sc_lock_base_latency_cy);

}
void
Cache_Controller::scLockIncLatency()
{
(*m_sc_lock_multiplier_ptr) = ((*m_sc_lock_multiplier_ptr) + m_sc_lock_multiplier_inc);
    if (((*m_sc_lock_multiplier_ptr) > m_sc_lock_multiplier_max)) {
        (*m_sc_lock_multiplier_ptr) = m_sc_lock_multiplier_max;
    }
    DPRINTF(LLSC, "CHI-cache-funcs.sm:1169: SC lock latency increased to %d cy\n", (scLockLatency()));

}
void
Cache_Controller::scLockDecayLatency()
{
(*m_sc_lock_multiplier_ptr) = ((*m_sc_lock_multiplier_ptr) - m_sc_lock_multiplier_decay);
    if (((*m_sc_lock_multiplier_ptr) < (0))) {
        (*m_sc_lock_multiplier_ptr) = (0);
    }
    DPRINTF(LLSC, "CHI-cache-funcs.sm:1178: SC lock latency decayed to %d cy\n", (scLockLatency()));

}
void
Cache_Controller::clearPendingAction(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_snd_pendEv) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_pendAction == Cache_Event_TX_Data))) {
            panic("Runtime Error at CHI-cache-funcs.sm:1184: %s for machine %s.\n", "assert failure", name());

        }
        #endif
        ;
    } else {
        (*param_tbe).m_pendAction = Cache_Event_null;
    }

}
bool
Cache_Controller::isReadReqType(const CHIRequestType& param_type)
{
    if (((((((param_type == CHIRequestType_Load) || (param_type == CHIRequestType_ReadShared)) || (param_type == CHIRequestType_ReadNotSharedDirty)) || (param_type == CHIRequestType_MakeReadUnique)) || (param_type == CHIRequestType_ReadNoSnp)) || (param_type == CHIRequestType_ReadOnce))) {
        return (true);
    }
    return (false);

}
bool
Cache_Controller::isWriteReqType(const CHIRequestType& param_type)
{
    if (((((((param_type == CHIRequestType_Store) || (param_type == CHIRequestType_StoreLine)) || (param_type == CHIRequestType_WriteUniquePtl)) || (param_type == CHIRequestType_WriteUniqueFull)) || (param_type == CHIRequestType_WriteUniqueZero)) || (param_type == CHIRequestType_ReadUnique))) {
        return (true);
    }
    return (false);

}
bool
Cache_Controller::isStashReqType(const CHIRequestType& param_type)
{
    if (((param_type == CHIRequestType_StashOnceShared) || (param_type == CHIRequestType_StashOnceUnique))) {
        return (true);
    }
    return (false);

}
Cache_Event
Cache_Controller::reqToEvent(const CHIRequestType& param_type, const bool& param_is_prefetch)
{
    if ((param_type == CHIRequestType_Load)) {
            if ((param_is_prefetch == (false))) {
                return Cache_Event_Load;
            } else {
                return Cache_Event_Prefetch;
            }
        } else {
                if ((param_type == CHIRequestType_Store)) {
                    return Cache_Event_Store;
                } else {
                        if ((param_type == CHIRequestType_StoreLine)) {
                            return Cache_Event_Store;
                        } else {
                                if ((param_type == CHIRequestType_AtomicLoad)) {
                                    return Cache_Event_AtomicLoad;
                                } else {
                                        if ((param_type == CHIRequestType_AtomicStore)) {
                                            return Cache_Event_AtomicStore;
                                        } else {
                                                if ((param_type == CHIRequestType_ReadShared)) {
                                                    return Cache_Event_ReadShared;
                                                } else {
                                                        if ((param_type == CHIRequestType_ReadNotSharedDirty)) {
                                                            return Cache_Event_ReadNotSharedDirty;
                                                        } else {
                                                                if ((param_type == CHIRequestType_ReadUnique)) {
                                                                        if (m_is_HN) {
                                                                            return Cache_Event_ReadUnique_PoC;
                                                                        } else {
                                                                            return Cache_Event_ReadUnique;
                                                                        }
                                                                    } else {
                                                                            if ((param_type == CHIRequestType_CleanUnique)) {
                                                                                return Cache_Event_CleanUnique;
                                                                            } else {
                                                                                    if ((param_type == CHIRequestType_ReadNoSnp)) {
                                                                                        return Cache_Event_ReadNoSnp;
                                                                                    } else {
                                                                                            if ((param_type == CHIRequestType_ReadOnce)) {
                                                                                                return Cache_Event_ReadOnce;
                                                                                            } else {
                                                                                                    if ((param_type == CHIRequestType_MakeReadUnique)) {
                                                                                                        return Cache_Event_MakeReadUnique;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIRequestType_Evict)) {
                                                                                                                return Cache_Event_Evict;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIRequestType_WriteBackFull)) {
                                                                                                                        return Cache_Event_WriteBackFull;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIRequestType_WriteEvictFull)) {
                                                                                                                                return Cache_Event_WriteEvictFull;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIRequestType_WriteCleanFull)) {
                                                                                                                                        return Cache_Event_WriteCleanFull;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIRequestType_WriteUniquePtl)) {
                                                                                                                                                    if (m_is_HN) {
                                                                                                                                                        return Cache_Event_WriteUniquePtl_PoC;
                                                                                                                                                    } else {
                                                                                                                                                        return Cache_Event_WriteUnique;
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                        if ((param_type == CHIRequestType_WriteUniqueFull)) {
                                                                                                                                                                if ((m_is_HN && m_alloc_on_writeback)) {
                                                                                                                                                                    return Cache_Event_WriteUniqueFull_PoC_Alloc;
                                                                                                                                                                } else {
                                                                                                                                                                        if (m_is_HN) {
                                                                                                                                                                            return Cache_Event_WriteUniqueFull_PoC;
                                                                                                                                                                        } else {
                                                                                                                                                                            return Cache_Event_WriteUnique;
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                } else {
                                                                                                                                                                        if ((param_type == CHIRequestType_WriteUniqueZero)) {
                                                                                                                                                                            return Cache_Event_WriteUniqueZero;
                                                                                                                                                                        } else {
                                                                                                                                                                                if ((param_type == CHIRequestType_StashOnceShared)) {
                                                                                                                                                                                    return Cache_Event_StashOnceShared;
                                                                                                                                                                                } else {
                                                                                                                                                                                        if ((param_type == CHIRequestType_StashOnceUnique)) {
                                                                                                                                                                                            return Cache_Event_StashOnceUnique;
                                                                                                                                                                                        } else {
                                                                                                                                                                                                if ((param_type == CHIRequestType_DvmTlbi_Initiate)) {
                                                                                                                                                                                                    return Cache_Event_DvmTlbi_Initiate;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                        if ((param_type == CHIRequestType_DvmSync_Initiate)) {
                                                                                                                                                                                                            return Cache_Event_DvmSync_Initiate;
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                if ((param_type == CHIRequestType_AtomicReturn)) {
                                                                                                                                                                                                                        if ((m_is_HN && m_alloc_on_atomic)) {
                                                                                                                                                                                                                            return Cache_Event_AtomicReturn_PoC_Alloc;
                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                if (m_is_HN) {
                                                                                                                                                                                                                                    return Cache_Event_AtomicReturn_PoC;
                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                    return Cache_Event_AtomicReturn;
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                if ((param_type == CHIRequestType_AtomicNoReturn)) {
                                                                                                                                                                                                                                        if ((m_is_HN && m_alloc_on_atomic)) {
                                                                                                                                                                                                                                            return Cache_Event_AtomicNoReturn_PoC_Alloc;
                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                if (m_is_HN) {
                                                                                                                                                                                                                                                    return Cache_Event_AtomicNoReturn_PoC;
                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                    return Cache_Event_AtomicNoReturn;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                            panic("Runtime Error at CHI-cache-funcs.sm:1307: %s for machine %s.\n", ("Invalid CHIRequestType"), name());
                                                                                                                                                                                                                                            ;
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }

}
Cache_Event
Cache_Controller::respToEvent(const CHIResponseType& param_type, Cache_TBE* param_tbe)
{
bool on_hazard
 = ((param_tbe != NULL) && ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard));
    if ((param_type == CHIResponseType_Comp_I)) {
        return Cache_Event_Comp_I;
    } else {
            if ((param_type == CHIResponseType_Comp_UC)) {
                return Cache_Event_Comp_UC;
            } else {
                    if ((param_type == CHIResponseType_Comp_SC)) {
                        return Cache_Event_Comp_SC;
                    } else {
                            if ((param_type == CHIResponseType_CompDBIDResp)) {
                                return Cache_Event_CompDBIDResp;
                            } else {
                                    if ((param_type == CHIResponseType_DBIDResp)) {
                                        return Cache_Event_DBIDResp;
                                    } else {
                                            if ((param_type == CHIResponseType_Comp)) {
                                                return Cache_Event_Comp;
                                            } else {
                                                    if ((param_type == CHIResponseType_CompAck)) {
                                                        return Cache_Event_CompAck;
                                                    } else {
                                                            if ((param_type == CHIResponseType_ReadReceipt)) {
                                                                return Cache_Event_ReadReceipt;
                                                            } else {
                                                                    if ((param_type == CHIResponseType_RespSepData)) {
                                                                        return Cache_Event_RespSepData;
                                                                    } else {
                                                                            if ((param_type == CHIResponseType_SnpResp_I)) {
                                                                                return Cache_Event_SnpResp_I;
                                                                            } else {
                                                                                    if ((param_type == CHIResponseType_SnpResp_I_Fwded_UC)) {
                                                                                        return Cache_Event_SnpResp_I_Fwded_UC;
                                                                                    } else {
                                                                                            if ((param_type == CHIResponseType_SnpResp_I_Fwded_UD_PD)) {
                                                                                                return Cache_Event_SnpResp_I_Fwded_UD_PD;
                                                                                            } else {
                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC)) {
                                                                                                        return Cache_Event_SnpResp_SC;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIResponseType_SnpResp_SC_Fwded_SC)) {
                                                                                                                return Cache_Event_SnpResp_SC_Fwded_SC;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD)) {
                                                                                                                        return Cache_Event_SnpResp_SC_Fwded_SD_PD;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIResponseType_SnpResp_SD_Fwded_I)) {
                                                                                                                                return Cache_Event_SnpResp_SD_Fwded_I;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC_Fwded_I)) {
                                                                                                                                        return Cache_Event_SnpResp_SC_Fwded_I;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIResponseType_SnpResp_UD_Fwded_I)) {
                                                                                                                                                return Cache_Event_SnpResp_UD_Fwded_I;
                                                                                                                                            } else {
                                                                                                                                                    if ((param_type == CHIResponseType_SnpResp_UC_Fwded_I)) {
                                                                                                                                                        return Cache_Event_SnpResp_UC_Fwded_I;
                                                                                                                                                    } else {
                                                                                                                                                            if ((param_type == CHIResponseType_RetryAck)) {
                                                                                                                                                                    if (m_is_HN) {
                                                                                                                                                                            if (on_hazard) {
                                                                                                                                                                                return Cache_Event_RetryAck_PoC_Hazard;
                                                                                                                                                                            } else {
                                                                                                                                                                                return Cache_Event_RetryAck_PoC;
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                                if (on_hazard) {
                                                                                                                                                                                    return Cache_Event_RetryAck_Hazard;
                                                                                                                                                                                } else {
                                                                                                                                                                                    return Cache_Event_RetryAck;
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                                if ((param_type == CHIResponseType_PCrdGrant)) {
                                                                                                                                                                                        if (m_is_HN) {
                                                                                                                                                                                                if (on_hazard) {
                                                                                                                                                                                                    return Cache_Event_PCrdGrant_PoC_Hazard;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    return Cache_Event_PCrdGrant_PoC;
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                    if (on_hazard) {
                                                                                                                                                                                                        return Cache_Event_PCrdGrant_Hazard;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        return Cache_Event_PCrdGrant;
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1380: %s for machine %s.\n", ("Invalid CHIResponseType"), name());
                                                                                                                                                                                                ;
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }

}
Cache_Event
Cache_Controller::dataToEvent(const CHIDataType& param_type)
{
    if ((param_type == CHIDataType_CompData_I)) {
        return Cache_Event_CompData_I;
    } else {
            if ((param_type == CHIDataType_CompData_UC)) {
                return Cache_Event_CompData_UC;
            } else {
                    if ((param_type == CHIDataType_CompData_SC)) {
                        return Cache_Event_CompData_SC;
                    } else {
                            if ((param_type == CHIDataType_CompData_UD_PD)) {
                                return Cache_Event_CompData_UD_PD;
                            } else {
                                    if ((param_type == CHIDataType_CompData_SD_PD)) {
                                        return Cache_Event_CompData_SD_PD;
                                    } else {
                                            if ((param_type == CHIDataType_DataSepResp_UC)) {
                                                return Cache_Event_DataSepResp_UC;
                                            } else {
                                                    if ((param_type == CHIDataType_CBWrData_I)) {
                                                        return Cache_Event_CBWrData_I;
                                                    } else {
                                                            if ((param_type == CHIDataType_CBWrData_UC)) {
                                                                return Cache_Event_CBWrData_UC;
                                                            } else {
                                                                    if ((param_type == CHIDataType_CBWrData_SC)) {
                                                                        return Cache_Event_CBWrData_SC;
                                                                    } else {
                                                                            if ((param_type == CHIDataType_CBWrData_UD_PD)) {
                                                                                return Cache_Event_CBWrData_UD_PD;
                                                                            } else {
                                                                                    if ((param_type == CHIDataType_CBWrData_SD_PD)) {
                                                                                        return Cache_Event_CBWrData_SD_PD;
                                                                                    } else {
                                                                                            if ((param_type == CHIDataType_NCBWrData)) {
                                                                                                return Cache_Event_NCBWrData;
                                                                                            } else {
                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_PD)) {
                                                                                                        return Cache_Event_SnpRespData_I_PD;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIDataType_SnpRespData_I)) {
                                                                                                                return Cache_Event_SnpRespData_I;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_PD)) {
                                                                                                                        return Cache_Event_SnpRespData_SC_PD;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC)) {
                                                                                                                                return Cache_Event_SnpRespData_SC;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SD)) {
                                                                                                                                        return Cache_Event_SnpRespData_SD;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_UC)) {
                                                                                                                                                return Cache_Event_SnpRespData_UC;
                                                                                                                                            } else {
                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_UD)) {
                                                                                                                                                        return Cache_Event_SnpRespData_UD;
                                                                                                                                                    } else {
                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC_Fwded_SC)) {
                                                                                                                                                                return Cache_Event_SnpRespData_SC_Fwded_SC;
                                                                                                                                                            } else {
                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) {
                                                                                                                                                                        return Cache_Event_SnpRespData_SC_Fwded_SD_PD;
                                                                                                                                                                    } else {
                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SD_Fwded_SC)) {
                                                                                                                                                                                return Cache_Event_SnpRespData_SD_Fwded_SC;
                                                                                                                                                                            } else {
                                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) {
                                                                                                                                                                                        return Cache_Event_SnpRespData_SC_PD_Fwded_SC;
                                                                                                                                                                                    } else {
                                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) {
                                                                                                                                                                                                return Cache_Event_SnpRespData_I_Fwded_SD_PD;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_PD_Fwded_SC)) {
                                                                                                                                                                                                        return Cache_Event_SnpRespData_I_PD_Fwded_SC;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_I_Fwded_SC)) {
                                                                                                                                                                                                                return Cache_Event_SnpRespData_I_Fwded_SC;
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1438: %s for machine %s.\n", ("Invalid CHIDataType"), name());
                                                                                                                                                                                                                ;
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }

}
Cache_Event
Cache_Controller::snpToEvent(const CHIRequestType& param_type)
{
    if ((param_type == CHIRequestType_SnpCleanInvalid)) {
        return Cache_Event_SnpCleanInvalid;
    } else {
            if ((param_type == CHIRequestType_SnpShared)) {
                return Cache_Event_SnpShared;
            } else {
                    if ((param_type == CHIRequestType_SnpUnique)) {
                        return Cache_Event_SnpUnique;
                    } else {
                            if ((param_type == CHIRequestType_SnpSharedFwd)) {
                                return Cache_Event_SnpSharedFwd;
                            } else {
                                    if ((param_type == CHIRequestType_SnpNotSharedDirtyFwd)) {
                                        return Cache_Event_SnpNotSharedDirtyFwd;
                                    } else {
                                            if ((param_type == CHIRequestType_SnpUniqueFwd)) {
                                                return Cache_Event_SnpUniqueFwd;
                                            } else {
                                                    if ((param_type == CHIRequestType_SnpOnce)) {
                                                        return Cache_Event_SnpOnce;
                                                    } else {
                                                            if ((param_type == CHIRequestType_SnpOnceFwd)) {
                                                                return Cache_Event_SnpOnceFwd;
                                                            } else {
                                                                    if ((param_type == CHIRequestType_SnpDvmOpSync_P1)) {
                                                                        return Cache_Event_SnpDvmOpSync_P1;
                                                                    } else {
                                                                            if ((param_type == CHIRequestType_SnpDvmOpSync_P2)) {
                                                                                return Cache_Event_SnpDvmOpSync_P2;
                                                                            } else {
                                                                                    if ((param_type == CHIRequestType_SnpDvmOpNonSync_P1)) {
                                                                                        return Cache_Event_SnpDvmOpNonSync_P1;
                                                                                    } else {
                                                                                            if ((param_type == CHIRequestType_SnpDvmOpNonSync_P2)) {
                                                                                                return Cache_Event_SnpDvmOpNonSync_P2;
                                                                                            } else {
                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1468: %s for machine %s.\n", ("Invalid CHIRequestType"), name());
                                                                                                ;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

}
void
Cache_Controller::recordRequestType(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
    if ((param_request_type == Cache_RequestType_DataArrayRead)) {
        (((*m_cache_ptr)).recordRequestType(CacheRequestType_DataArrayRead, param_addr));
    } else {
            if ((param_request_type == Cache_RequestType_DataArrayWrite)) {
                (((*m_cache_ptr)).recordRequestType(CacheRequestType_DataArrayWrite, param_addr));
            } else {
                    if ((param_request_type == Cache_RequestType_TagArrayRead)) {
                        (((*m_cache_ptr)).recordRequestType(CacheRequestType_TagArrayRead, param_addr));
                    } else {
                            if ((param_request_type == Cache_RequestType_TagArrayWrite)) {
                                (((*m_cache_ptr)).recordRequestType(CacheRequestType_TagArrayWrite, param_addr));
                            }
                        }
                    }
                }

}
bool
Cache_Controller::_checkResourceAvailable(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
    if ((param_request_type == Cache_RequestType_DataArrayRead)) {
        return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_DataArray, param_addr));
    } else {
            if ((param_request_type == Cache_RequestType_DataArrayWrite)) {
                return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_DataArray, param_addr));
            } else {
                    if ((param_request_type == Cache_RequestType_TagArrayRead)) {
                        return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_TagArray, param_addr));
                    } else {
                            if ((param_request_type == Cache_RequestType_TagArrayWrite)) {
                                return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_TagArray, param_addr));
                            } else {
                                    if ((param_request_type == Cache_RequestType_DestinationAvailable)) {
                                            if (m_throttle_req_on_retry) {
                                                MachineID dest
                                                 = (mapAddressToDownstreamMachine(param_addr));
                                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:1510: Checking %s for addr %#x dest %s\n", param_request_type, param_addr, dest);
                                                return ((((*m_destsWaitingRetry_ptr)).isElement(dest)) == (false));
                                            } else {
                                                return (true);
                                            }
                                        } else {
                                                if ((param_request_type == Cache_RequestType_ReplTBEAvailable)) {
                                                    return (m_unify_repl_TBEs || (((*m_storReplTBEs_ptr)).areNSlotsAvailable((1))));
                                                } else {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:1520: %s for machine %s.\n", ("Invalid RequestType type in checkResourceAvailable"), name());
                                                    ;
                                                    return (true);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

}
bool
Cache_Controller::checkResourceAvailable(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
bool avail
 = (_checkResourceAvailable(param_request_type, param_addr));
    if ((avail == (false))) {
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:1528: Resource %s not available for addr: %#x\n", param_request_type, param_addr);
    }
    return avail;

}
bool
Cache_Controller::rspInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:97: %s for machine %s.\n", ("rspInPort must never stall\n"), name());
;
return (false);

}
bool
Cache_Controller::datInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:117: %s for machine %s.\n", ("datInPort must never stall\n"), name());
;
return (false);

}
bool
Cache_Controller::snpRdyPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:154: %s for machine %s.\n", ("snpRdyPort must never stall\n"), name());
;
return (false);

}
void
Cache_Controller::wakeupPendingSnps(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_snp) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_snp = (false);
    }

}
bool
Cache_Controller::retryTriggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:227: Retry trigger queue resource stall\n");
(((*m_retryTriggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
bool
Cache_Controller::triggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:262: Trigger queue resource stall\n");
(((*m_triggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
Cache_Controller::wakeupPendingTgrs(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_tgr) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_triggerQueue_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_tgr = (false);
    }

}
bool
Cache_Controller::reqRdyPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:359: ReqRdy queue resource stall\n");
(((*m_reqRdy_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
Cache_Controller::wakeupPendingReqs(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_req) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_reqRdy_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_req = (false);
    }

}
bool
Cache_Controller::reqInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:392: %s for machine %s.\n", ("reqInPort must never stall\n"), name());
;
return (false);

}
void
Cache_Controller::processNextState(const Addr& param_address, Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-ports.sm:446: %s for machine %s.\n", "assert failure", name());

}
#endif
;
DPRINTF(RubySlicc, "CHI-cache-ports.sm:447: GoToNextState expected_req_resp=%d expected_snp_resp=%d snd_pendEv=%d snd_pendBytes=%d\n", (((*param_tbe).m_expected_req_resp).expected()), (((*param_tbe).m_expected_snp_resp).expected()), (*param_tbe).m_snd_pendEv, (((*param_tbe).m_snd_pendBytes).count()));
bool has_nb_trigger
 = ((((((*param_tbe).m_actions).empty()) == (false)) && (((*param_tbe).m_actions).frontNB())) && ((*param_tbe).m_snd_pendEv == (false)));
int expected_msgs
 = (((((*param_tbe).m_expected_req_resp).expected()) + (((*param_tbe).m_expected_snp_resp).expected())) + (((*param_tbe).m_snd_pendBytes).count()));
    if ((((*param_tbe).m_pendAction == Cache_Event_null) && ((expected_msgs == (0)) || has_nb_trigger))) {
        Cycles trigger_latency
         = (intToCycles((0)));
            if (((*param_tbe).m_delayNextAction > (curTick()))) {
                trigger_latency = ((ticksToCycles((*param_tbe).m_delayNextAction)) - (ticksToCycles((curTick()))));
                (*param_tbe).m_delayNextAction = (intToTick((0)));
            }
            (*param_tbe).m_pendAction = Cache_Event_null;
                if ((((*param_tbe).m_actions).empty())) {
                    (*param_tbe).m_pendAction = Cache_Event_Final;
                } else {
                    (*param_tbe).m_pendAction = (((*param_tbe).m_actions).front());
                    (((*param_tbe).m_actions).pop());
                }
                #ifndef NDEBUG
                if (!(((*param_tbe).m_pendAction != Cache_Event_null))) {
                    panic("Runtime Error at CHI-cache-ports.sm:476: %s for machine %s.\n", "assert failure", name());

                }
                #endif
                ;
                {
                    std::shared_ptr<Cache_TriggerMsg> out_msg = std::make_shared<Cache_TriggerMsg>(clockEdge(),     m_ruby_system->getBlockSizeBytes(), m_ruby_system);
                    (*out_msg).m_addr = (*param_tbe).m_addr;
                    (*out_msg).m_usesTxnId = ((*param_tbe).m_is_dvm_tbe || (*param_tbe).m_is_dvm_snp_tbe);
                    (*out_msg).m_from_hazard = ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard);
                    ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(trigger_latency)), m_ruby_system->getRandomization(), m_ruby_system->getWarmupEnabled());
                }
            }
            (printTBEState(param_tbe));
            (wakeupPendingSnps(param_tbe));

}
int
Cache_Controller::functionalWriteBuffers(PacketPtr& pkt)
{
    int num_functional_writes = 0;
num_functional_writes += m_reqOut_ptr->functionalWrite(pkt);
num_functional_writes += m_snpOut_ptr->functionalWrite(pkt);
num_functional_writes += m_rspOut_ptr->functionalWrite(pkt);
num_functional_writes += m_datOut_ptr->functionalWrite(pkt);
num_functional_writes += m_reqIn_ptr->functionalWrite(pkt);
num_functional_writes += m_snpIn_ptr->functionalWrite(pkt);
num_functional_writes += m_rspIn_ptr->functionalWrite(pkt);
num_functional_writes += m_datIn_ptr->functionalWrite(pkt);
num_functional_writes += m_mandatoryQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_triggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_retryTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_reqRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_snpRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_replTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_prefetchQueue_ptr->functionalWrite(pkt);
    return num_functional_writes;
}
bool
Cache_Controller::functionalReadBuffers(PacketPtr& pkt)
{
if (m_reqOut_ptr->functionalRead(pkt)) return true;
if (m_snpOut_ptr->functionalRead(pkt)) return true;
if (m_rspOut_ptr->functionalRead(pkt)) return true;
if (m_datOut_ptr->functionalRead(pkt)) return true;
if (m_reqIn_ptr->functionalRead(pkt)) return true;
if (m_snpIn_ptr->functionalRead(pkt)) return true;
if (m_rspIn_ptr->functionalRead(pkt)) return true;
if (m_datIn_ptr->functionalRead(pkt)) return true;
if (m_mandatoryQueue_ptr->functionalRead(pkt)) return true;
if (m_triggerQueue_ptr->functionalRead(pkt)) return true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_reqRdy_ptr->functionalRead(pkt)) return true;
if (m_snpRdy_ptr->functionalRead(pkt)) return true;
if (m_replTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_prefetchQueue_ptr->functionalRead(pkt)) return true;
    return false;
}

bool
Cache_Controller::functionalReadBuffers(PacketPtr& pkt, WriteMask &mask)
{
    bool read = false;
if (m_reqOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_datOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_datIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_mandatoryQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_triggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_replTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_prefetchQueue_ptr->functionalRead(pkt, mask)) read = true;
    return read;
}

} // namespace CHI
} // namespace ruby
} // namespace gem5
